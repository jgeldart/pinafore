Notation4:
  Ontology | Lexicon
;

//////// Ontology

Ontology:
  'ontology'
  baseIRI=IRI
  noPrelude?=NoPrelude
  (END_OF_PROP
  annotations*=AssertionPredicateBlock[';'])?
  END_OF_SUBJ
  ('default' 'language' lang=LANG END_OF_SUBJ)?
  pragmas*=Pragma
  assertions*=Assertion
;

NoPrelude:
  'without' 'prelude'
;


//////// Parsing pragmas

Pragma:
  Import | Keyword
;

Import:
  'import'
  baseIRI=IRI
  'as'
  name=ID
  ('from'
    fileName=STRING
  )?
  END_OF_SUBJ
;

Keyword:
  export?='exported'
  'keyword'
  ref=ResourceRef
  'as'
  name=ID
  END_OF_SUBJ
;


//////// Assertions

Assertion:
  (ClassDeclaration | PropertyDeclaration | AttributeDeclaration | DatatypeDeclaration | QuantityDeclaration | FactAssertion | GraphAssertion | BNodeAssertion)
  END_OF_SUBJ
;


//////// Class declarations

ClassDeclaration:
  'class' 
  (subclass=ClassExpressionPrimary | name=ClassRef)
  (END_OF_PROP?
   axioms*=CIAxiom[';']
  )
;

CIAxiom:
    Superclass | EquivalentClass | AssertionPredicateBlock
;

Superclass:
  '<|' superclass=ClassExpression
;

EquivalentClass:
  '~=' equivalentclass=ClassExpression
;


//////// Property/object property declarations

PropertyDeclaration:
  (functional?='functional' inverseFunctional?='inversefunctional' reflexive?='reflexive' irreflexive?='irreflexive' symmetric?='symmetric' asymmetric?='asymmetric' transitive?='transitive')#
  'property'
  (subprop=PropertyExpressionChain | name=PropertyRef)
  (END_OF_PROP?
   axioms*=PIAxiom[';']
  )
;

PIAxiom:
  Superproperty | EquivalentProperty | AssertionPredicateBlock
;

Superproperty:
  '<|' superproperty=PropertyExpressionDisjunction
;

EquivalentProperty:
  '~=' equivalentProperty=PropertyExpressionDisjunction
;


//////// Attribute/data property declarations

AttributeDeclaration:
  'attribute'
  name=AttributeRef
  (('with' 'domain' domain=AttributeDomain)? ('with' 'range' range=AttributeRange)?)#
  (END_OF_PROP?
   axioms*=AIAxiom[';']
  )
;

AttributeDomain:
  'domain' domain=ClassExpression
;

AttributeRange:
  'range' range=DataRestriction
;

AIAxiom:
  Superattribute | EquivalentAttribute | AssertionPredicateBlock
;

Superattribute:
  '<|' superattribute=AttributeRef
;

EquivalentAttribute:
  '~=' equivalentAttribute=AttributeRef
;

AttributeRef:
  PropertyRef
;


//////// Datatype declarations

DatatypeDeclaration:
  'datatype' name=DatatypeRef '<|' restriction=DataRestriction
  (END_OF_PROP?
   axioms*=AssertionPredicateBlock[';']
  )
;

DatatypeRef:
  IRIRef | QNameRef
;


//////// Quantity declarations

QuantityDeclaration:
  'quantity' name=QuantityRef ((('with' 'dimension' dimension=DimensionRef) | ('with' 'unit' (restriction=RangeExpressionNumber)? unit=UnitRef))? ('with' 'property' prop=PropertyRef)?)#
  ( END_OF_PROP?
    axioms*=CIAxiom[';']
  )
;

QuantityRef:
  IRIRef | QNameRef
;

DimensionRef:
  IRIRef | QNameRef
;

UnitRef:
  IRIRef | QNameRef
;

//////// BNode assertions

BNodeAssertion:
  '['
  label=BNodeLabel?
  predicates*=AssertionPredicateBlock[';']
  END_OF_PROP?
  ']'
;

BNodeAssertionFormula:
  '['
  label=BNodeLabelFormula?
  predicates*=FormulaAssertionPredicateBlock[';']
  END_OF_PROP?
  ']'
;


//////// Graph/formula assertions

GraphAssertion:
 '{'
 label=GraphNodeLabel?
 assertions+=Assertion
 '}'
;

GraphAssertionFormula:
 '{'
 label=GraphNodeLabelFormula?
 assertions+=FormulaAssertion
 '}'
;


//////// Fact assertions

FactAssertion:
  subject=AssertionSubject
  predicates+=AssertionPredicateBlock[';']
;

AssertionPredicateBlock:
  predicate=AssertionPredicate
  objects+=AssertionObject[',']
;


AssertionSubject:
    HeadedList
  | ResourceRef
  | Formula
  | BNodeAssertion
  | Collection
;

AssertionPredicate:
    BuiltinPredicate
  | ResourceRef
;

AssertionObject:
    Literal
  | HeadedList
  | ResourceRef
  | Formula
  | BNodeAssertion
  | '(' InfixExpression ')'
  | Collection
;


//////// Resources

ResourceRef:
  IRIRef | QNameRef
;

IRIRef:
  iri=IRI
;

QNameRef[noskipws]:
  /\s*/ (prefix=[Import] ':')? localName=ID
;

BNodeLabel:
  ':-'- name=ResourceRef END_OF_SUBJ-
;

BNodeLabelFormula:
  ':-'- name=ResourceRefFormula END_OF_SUBJ-
;

GraphNodeLabel:
  ':-'- name=ResourceRef (END_OF_PROP metadata+=AssertionPredicateBlock[';'])? END_OF_SUBJ-
;

GraphNodeLabelFormula:
  ':-'- name=ResourceRefFormula (END_OF_PROP metadata+=FormulaAssertionPredicateBlock[';'])? END_OF_SUBJ-
;

ExistentialVariable:
  '!' name=ID
;

UniversalVariable:
  '?' name=ID
;

BuiltinPredicate[noskipws]:
  /\s+/
  ( IsaPredicate
  | SuperPredicate
  | EquivalentPredicate
  | BackwardChainPredicate
  | ForwardChainPredicate
  | LogicalIdenticalPredicate
  | LogicalDifferentPredicate
  | NumericEqualsPredicate
  | NumericNotEqualsPredicate
  | NumericLessThanEqualsPredicate
  | NumericLessThanPredicate
  | NumericGreaterThanEqualsPredicate
  | NumericGreaterThanPredicate
  | LogicalEqualsPredicate
  | LogicalNotEqualsPredicate
  | LogicalSemanticsPredicate
  | LogicalConclusionsPredicate
  | CollectionInclusionPredicate
  )
  /\s+/
;

IsaPredicate: op='a';
SuperPredicate: op='<|';
EquivalentPredicate: op='~=';
BackwardChainPredicate: op='<--';
ForwardChainPredicate: op='<==';
LogicalEqualsPredicate: op='=';
LogicalNotEqualsPredicate: op='=/=';
NumericEqualsPredicate: op='==';
NumericNotEqualsPredicate: op='!=';
NumericLessThanEqualsPredicate: op='<=';
NumericLessThanPredicate: op='<';
NumericGreaterThanEqualsPredicate: op='>=';
NumericGreaterThanPredicate: op='>';
LogicalSemanticsPredicate: op='|-';
LogicalConclusionsPredicate: op='|=';
LogicalIdenticalPredicate: op='===';
LogicalDifferentPredicate: op='!==';
CollectionInclusionPredicate: op='in';


//////// Formulas

Formula:
  '{'
    assertions*=FormulaAssertion['.']
    END_OF_SUBJ?
  '}'
;

FormulaAssertion:
  subject=FormulaAssertionSubject
  predicate+=FormulaAssertionPredicateBlock[';']
;

FormulaAssertionPredicateBlock:
  predicate=FormulaAssertionPredicate
  objects+=FormulaAssertionObject[',']
;

FormulaAssertionSubject:
    HeadedListFormula
  | ResourceRefFormula
  | GraphAssertionFormula
  | BNodeAssertionFormula
  | '(' InfixExpressionFormula ')'
  | CollectionFormula
;

FormulaAssertionPredicate:
    BuiltinPredicate
  | PredicatePathExpression
  | ResourceRefFormula
;

FormulaAssertionObject:
    Literal
  | HeadedListFormula
  | ResourceRefFormula
  | GraphAssertionFormula
  | BNodeAssertionFormula
  | '(' InfixExpressionFormula ')'
  | CollectionFormula
;

ResourceRefFormula:
  ExistentialVariable | UniversalVariable | IRIRef | QNameRef
;

//////// List expressions

HeadedList:
  head=ResourceRef '(' members*=HeadedListObject[','] ')'
;

HeadedListObject:
    InfixExpression
  | LiteralExpression
  | HeadedList
  | BNodeAssertion
  | GraphAssertion
  | ResourceRef
  | Collection
;

HeadedListFormula:
  head=ResourceRefFormula '(' members*=HeadedListFormulaObject[','] ')'
;

HeadedListFormulaObject:
    InfixExpressionFormula
  | LiteralExpression
  | HeadedListFormula
  | BNodeAssertionFormula
  | GraphAssertionFormula
  | ResourceRefFormula
  | CollectionFormula
;

Collection:
  (collectionType=CollectionType)? '(' members*=AssertionObject[','] ')'
;

CollectionFormula:
  (collectionType=CollectionType)? '(' members*=FormulaAssertionObject[','] ')'
;

CollectionType:
    CollectionTypeBag
  | CollectionTypeSet
  | CollectionTypeAlts
  | CollectionTypeSeq
;

CollectionTypeBag: type='@bag';
CollectionTypeSet: type='@set';
CollectionTypeAlts: type='@alts';
CollectionTypeSeq: type='@seq';

//////// Infix expressions

InfixExpression:
  InfixAdditive
;

InfixAdditive:
  operands=InfixMultiplicative (operator=KW_ADDITIVE operands=InfixAdditive)?
;

InfixMultiplicative:
  operands=InfixExponential (operator=KW_MULTIPLICATIVE operands=InfixMultiplicative)?
;

InfixExponential:
  operands=InfixNumericAtom (operator=KW_EXPONENTIAL operands=InfixExponential)?
;

InfixNumericAtom:
  NumericLiteralExpression | '(' InfixExpression ')' 
;


InfixExpressionFormula:
  InfixAdditiveFormula
;

InfixAdditiveFormula:
  operands=InfixMultiplicativeFormula (operator=KW_ADDITIVE operands=InfixAdditiveFormula)?
;

InfixMultiplicativeFormula:
  operands=InfixExponentialFormula (operator=KW_MULTIPLICATIVE operands=InfixMultiplicativeFormula)?
;

InfixExponentialFormula:
  operands=InfixNumericAtomFormula (operator=KW_EXPONENTIAL operands=InfixExponentialFormula)?
;

InfixNumericAtomFormula:
  UniversalVariable | ExistentialVariable | NumericLiteralExpression | '(' InfixExpressionFormula ')' 
;

KW_ADDITIVE:
  KW_ADDITIVE_PLUS | KW_ADDITIVE_MINUS
;

KW_ADDITIVE_PLUS:
  op='+'
;

KW_ADDITIVE_MINUS:
  op='-'
;

KW_MULTIPLICATIVE:
  KW_MULTIPLICATIVE_TIMES | KW_MULTIPLICATIVE_DIVIDE
;

KW_MULTIPLICATIVE_TIMES:
  op='*'
;

KW_MULTIPLICATIVE_DIVIDE:
  op='/'
;

KW_EXPONENTIAL:
  op='^'
;


//////// Path expressions

PredicatePathExpression:
  PredicatePathExpressionAlternatives
;

PredicatePathExpressionAlternatives:
  alts+=PredicatePathExpressionPath['|']
;

PredicatePathExpressionPath:
  elements=PredicatePathExpressionElement (operator=KW_PATH_OPERATOR elements=PredicatePathExpressionPath)?
;

PredicatePathExpressionElement:
  negated?='!'
  element=PredicatePathExpressionAtom
  (repeat=PredicatePathExpressionRepeat)?
;

PredicatePathExpressionAtom:
  PropertyRef | '(' PredicatePathExpression ')'
;

PredicatePathExpressionRepeat:
    PredicatePathExpressionRepeatZeroOrMore 
  | PredicatePathExpressionRepeatOneOrMore 
  | PredicatePathExpressionRepeatOptional 
  | PredicatePathExpressionRepeatCount
;

PredicatePathExpressionRepeatZeroOrMore: op='*';
PredicatePathExpressionRepeatOneOrMore: op='+';
PredicatePathExpressionRepeatOptional: op='?';
PredicatePathExpressionRepeatCount:
  '{' (lower=INT)? '..' (upper=INT)? '}'
;

KW_PATH_OPERATOR:
  KW_PATH_OPERATOR_BACKWARD | KW_PATH_OPERATOR_FORWARD
;

KW_PATH_OPERATOR_BACKWARD: op='/^';
KW_PATH_OPERATOR_FORWARD: op='/';


//////// Class expressions

ClassRef:
  IRIRef | QNameRef
;

ClassExpression:
  ClassDescription
;

ClassDescription:
  disjuncts+=ClassExpressionConjunction['or']
;

ClassExpressionConjunction:
    (
      baseClass=ClassRef 'that' restrictions+=ClassExpressionPrimary['and']
    | restrictions+=ClassExpressionPrimary['and']
    ) 
    ('if' condition=ClassExpressionPrimary)?
;

ClassExpressionPrimary:
  negated?='not'
  klass=ClassExpressionAtom
;

ClassExpressionRestriction:
    ClassExpressionRestrictionMaxCard
  | ClassExpressionRestrictionMinCard
  | ClassExpressionRestrictionExactCard
  | ClassExpressionRestrictionOnlySome
  | ClassExpressionRestrictionOnly
  | ClassExpressionRestrictionSome
  | ClassExpressionRestrictionQuantity
  | ClassExpressionRestrictionPortion
  | ClassExpressionRestrictionSelf
  | ClassExpressionRestrictionValue
;

ClassExpressionRestrictionOnlySome:
  role=PropertyExpression 'only' 'a' restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionOnly:
  role=PropertyExpression 'only' restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionSome:
  role=PropertyExpression 'a' restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionMaxCard:
  role=PropertyExpression 'at' 'most' cardinality=INT restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionMinCard:
  role=PropertyExpression 'at' 'least' cardinality=INT restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionExactCard:
  role=PropertyExpression 'exactly' cardinality=INT restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionQuantity:
  role=PropertyExpression  'measuring' restriction=QuantityValueRestriction unit=ResourceRef (aggregateFunction=ValueAggregateFunction)?
;

ClassExpressionRestrictionPortion:
  (restriction=QuantityValueRestriction unit=ResourceRef)? 'portion' klass=ClassExpressionPrimary 
;

QuantityValueRestriction:
    RangeExpressionNumber
  | QuantityValueRestrictionExact
;

QuantityValueRestrictionExact:
  value=NumberLiteralExpression
;

ValueAggregateFunction:
    ValueAggregateFunctionTotal 
  | ValueAggregateFunctionMaximum 
  | ValueAggregateFunctionMinimum 
  | ValueAggregateFunctionAverage
;

ValueAggregateFunctionTotal: op='total';
ValueAggregateFunctionMaximum: op='maximum';
ValueAggregateFunctionMinimum: op='minimum';
ValueAggregateFunctionAverage: op='average';

ClassExpressionRestrictionSelf:
  role=PropertyExpression 'itself'
;

ClassExpressionRestrictionValue:
  role=PropertyExpression 'is' value=ValueRestriction (aggregateFunction=ValueAggregateFunction)?
;


ClassExpressionAtom:
  ClassExpressionModal | ClassExpressionTemporal | ClassExpressionRestriction | ClassExpressionEnumeration | '(' ClassExpression ')' | ClassRef
;

ClassExpressionEnumeration:
  '{' individuals+=ValueRestriction[','] '}'
;

ClassExpressionModal:
  operator=ModalOperator
  klass=ClassExpressionPrimary
  ( 'when'
    condition=ClassExpressionPrimary
  )?
;

ModalOperator:
    ModalOperatorDeontic
  | ModalOperatorAlethic
  | ModalOperatorEpistemic
  | ModalOperatorTemporal
;

ModalOperatorDeontic:
    ModalOperatorObligation
  | ModalOperatorPermission
  | ModalOperatorProhibition
  | ModalOperatorOmission
  | ModalOperatorOption
;

ModalOperatorObligation: op='must';
ModalOperatorPermission: op='may';
ModalOperatorProhibition: op='cannot';
ModalOperatorOmission: op='might';
ModalOperatorOption: op='could';

ModalOperatorAlethic:
    ModalOperatorNecessary
  | ModalOperatorPossible
  | ModalOperatorCurrent
;

ModalOperatorNecessary: op='necessarily';
ModalOperatorPossible: op='possibly';
ModalOperatorCurrent: op='currently';

ModalOperatorEpistemic:
    ModalOperatorAssumption
  | ModalOperatorProvably
  | ModalOperatorPurportedly
  | ModalOperatorLikely
;

// ModalOperatorKnown: op='certainly'; This was semantically equivalent to purportedly
ModalOperatorAssumption: op='presumably';
ModalOperatorProvably: op='provably'; // Known and with a validated proof
ModalOperatorPurportedly: op='purportedly'; // Known without a validated proof
ModalOperatorLikely: op='likely'; // Balance of evidence favours this

ModalOperatorTemporal:
    ModalOperatorRepeat
  | ModalOperatorSafety
  | ModalOperatorLiveness
  | ModalOperatorOnce
;

ModalOperatorRepeat: op='repeatedly';
ModalOperatorSafety: op='never';
ModalOperatorLiveness: op='inevitably';
ModalOperatorOnce: op='once';

ClassExpressionTemporal:
    ClassExpressionTemporalNext
  | ClassExpressionTemporalEventually
  | ClassExpressionTemporalAlways
  | ClassExpressionTemporalReleases
  | ClassExpressionTemporalUntil
  | ClassExpressionTemporalJust
  | ClassExpressionTemporalWas
  | ClassExpressionTemporalHistorically
  | ClassExpressionTemporalSince
  | ClassExpressionTemporalFrom
;

ClassExpressionTemporalNext:
  'next' klass=ClassExpressionPrimary
;

ClassExpressionTemporalEventually:
  'eventually' klass=ClassExpressionPrimary
;

ClassExpressionTemporalAlways:
  'always' klass=ClassExpressionPrimary
;

ClassExpressionTemporalReleases:
  'up' 'until' trigger=ClassExpressionPrimary klass=ClassExpressionPrimary 
;

ClassExpressionTemporalUntil:
  'until' trigger=ClassExpressionPrimary klass=ClassExpressionPrimary 
;

ClassExpressionTemporalJust:
  'just' klass=ClassExpressionPrimary
;

ClassExpressionTemporalWas:
  'was' klass=ClassExpressionPrimary
;

ClassExpressionTemporalHistorically:
  'historically' klass=ClassExpressionPrimary
;

ClassExpressionTemporalSince:
  'since' trigger=ClassExpressionPrimary klass=ClassExpressionPrimary 
;

ClassExpressionTemporalFrom:
  'from' trigger=ClassExpressionPrimary klass=ClassExpressionPrimary 
;


//////// Property expressions


PropertyRef:
  IRIRef | QNameRef
;

PropertyExpression:
    (leftPlural=PluralOperator prop=PropertyExpressionChain)
  | (prop=PropertyExpressionChain (rightPlural=PluralOperator)?)
;

PluralOperator:
  PluralOperatorCumulative | PluralOperatorDistributive
;

PluralOperatorCumulative: op='variously';
PluralOperatorDistributive: op='separately';

PropertyExpressionChain:
  props+=PropertyExpressionDisjunction['of']
;

PropertyExpressionDisjunction:
  disjuncts+=PropertyExpressionConjunction['or']
;

PropertyExpressionConjunction:
  conjuncts+=PropertyExpressionPrimary['and']
;

PropertyExpressionPrimary:
  negated?='not'
  prop=PropertyExpressionAtom
;

PropertyExpressionAtom:
  PropertyExpressionTop | PropertyExpressionInverse | PropertyExpressionCartesian | PropertyExpressionQuantity | '(' PropertyExpression ')' | PropertySelf | PropertyRef
;

PropertyExpressionInverse:
  'inverse' prop=PropertyExpressionPrimary
;

PropertyExpressionCartesian:
  (('with' 'domain' domain=ClassExpressionPrimary)? ('with' 'range' range=ClassExpressionPrimary)?)#
;

PropertyExpressionQuantity:
  'the' 'quantity' quantity=QuantityRef
;

PropertyExpressionTop:
  op='something'
;

PropertySelf:
  'its'
;


//////// Data expressions

DataRestriction:
  ('_' | dataType=ResourceRef) facets*=DataFacetRestriction
;

ValueRestriction:
    LiteralExpression
  | NominalVariable
  | NominalRelationship
  | ResourceRef
;

NominalRelationship:
  ('the' | locallyRooted='its') prop=PropertyExpressionChain
;

NominalVariable:
  '$' name=ID
;

DataFacetRestriction:
  '[' DataFacet ']'
;

DataFacet:
    '>' minExclusive=NumericLiteralExpression
  | '>=' minInclusive=NumericLiteralExpression
  | '<' maxExclusive=NumericLiteralExpression
  | '<=' maxInclusive=NumericLiteralExpression
  | '=' equal=NumericLiteralExpression
  | 'length' '<' maxExclusiveLength=INT
  | 'length' '<=' maxInclusiveLength=INT
  | 'length' '>' minExclusiveLength=INT
  | 'length' '>=' minInclusiveLength=INT
  | 'length' '=' length=INT
  | 'matches' pattern=STRING
;

//////// Lexicon

Lexicon:
  'lexicon'
  baseIRI=IRI
  noPrelude?=NoPrelude
  (END_OF_PROP
   annotations*=AssertionPredicateBlock[';']
  )?
  END_OF_SUBJ
  ('language' lang=LANG END_OF_SUBJ)?
  pragmas*=Pragma
  entries*=LexicalEntry
;

LexicalEntry:
  component+=LexicalEntryComponent (',' partOfSpeech=ResourceRef)? ';'
  (annotations+=LexicalEntryAnnotation[';'] END_OF_PROP)?
  senses+=LexicalSense
  END_OF_SUBJ
;

LexicalEntryComponent:
  LexicalEntryAtom
;

LexicalEntryAtom:
  ResourceRef | '(' LexicalEntryComponent ')'
;

LexicalEntryAnnotation:
  predicate=LexicalEntryPredicate
  objects+=LexicalEntryObject[',']
;

LexicalEntryPredicate:
  ResourceRef
;

LexicalEntryObject:
  AssertionObject
;

LexicalSense:
  '*' ('(' modifers+=LexicalSenseModifier[','] ')')? ('TODO' | definition=LexicalSenseDefinition) ';'
  annotations*=LexicalEntryAnnotation[';']
;

LexicalSenseModifier:
  LexicalSenseModifierRegister | LexicalSenseModifierTemporal | LexicalSenseModifierNormative
;

LexicalSenseModifierRegister:
    LexicalSenseModifierRegisterBench
  | LexicalSenseModifierRegisterDialect
  | LexicalSenseModifierRegisterFacetious
  | LexicalSenseModifierRegisterFormal
  | LexicalSenseModifierRegisterInHouse
  | LexicalSenseModifierRegisterIronic
  | LexicalSenseModifierRegisterNeutral
  | LexicalSenseModifierRegisterSlang
  | LexicalSenseModifierRegisterTaboo
  | LexicalSenseModifierRegisterTechnical
  | LexicalSenseModifierRegisterVulgar
;

LexicalSenseModifierRegisterBench: op='bench';
LexicalSenseModifierRegisterDialect: op='dialect';
LexicalSenseModifierRegisterFacetious: op='facetious';
LexicalSenseModifierRegisterFormal: op='formal';
LexicalSenseModifierRegisterInHouse: op='in-house';
LexicalSenseModifierRegisterIronic: op='ironic';
LexicalSenseModifierRegisterNeutral: op='neutral';
LexicalSenseModifierRegisterSlang: op='slang';
LexicalSenseModifierRegisterTaboo: op='taboo';
LexicalSenseModifierRegisterTechnical: op='technical';
LexicalSenseModifierRegisterVulgar: op='vulgar';

LexicalSenseModifierTemporal:
    LexicalSenseModiferTemporalArchaic
  | LexicalSenseModifierTemporalObsolete
  | LexicalSenseModifierTemporalOutdated
;

LexicalSenseModiferTemporalArchaic: op='archaic';
LexicalSenseModifierTemporalObsolete: op='obsolete';
LexicalSenseModifierTemporalOutdated: op='outdated';

LexicalSenseModifierNormative:
    LexicalSenseModifierNormativeAdmitted
  | LexicalSenseModifierNormativeDeprecated
  | LexicalSenseModifierNormativeLegal
  | LexicalSenseModifierNormativePreferred
  | LexicalSenseModifierNormativeRegulated
  | LexicalSenseModifierNormativeStandardized
  | LexicalSenseModifierNormativeSuperseded
;

LexicalSenseModifierNormativeAdmitted: op='admitted';
LexicalSenseModifierNormativeDeprecated: op='deprecated';
LexicalSenseModifierNormativeLegal: op='legal';
LexicalSenseModifierNormativePreferred: op='preferred';
LexicalSenseModifierNormativeRegulated: op='regulated';
LexicalSenseModifierNormativeStandardized: op='standardized';
LexicalSenseModifierNormativeSuperseded: op='superseded';

LexicalSenseDefinition:
    LexicalSenseDefinitionClass
  | LexicalSenseDefinitionProperty
;

LexicalSenseDefinitionClass:
  'a' (klass=ResourceRef | klass=ClassExpression)
;

LexicalSenseDefinitionProperty:
  (meaning=LexicalSenseDefinitionPropertyAssertion | meaning=LexicalSenseDefinitionGraph)
  ('where' conditions+=LexicalSenseDefinitionCondition[','])
;

LexicalSenseDefinitionGraph:
  '{' assertions+=LexicalSenseDefinitionPropertyAssertion['.'] '}'
;

LexicalSenseDefinitionPropertyAssertion:
  subject=LexicalSenseDefinitionPropertySubject
  predicates+=LexicalSenseDefinitionPropertyPredicateBlock[';']
;

LexicalSenseDefinitionPropertySubject:
    ResourceRef
  | LexicalSenseArgument
  | LexicalSenseBNode
;

LexicalSenseDefinitionPropertyPredicateBlock:
  predicate=LexicalSenseDefinitionPropertyPredicate
  objects+=LexicalSenseDefinitionPropertyObject[',']
;

LexicalSenseDefinitionPropertyPredicate:
    BuiltinPredicate
  | ResourceRef
;

LexicalSenseDefinitionPropertyObject:
    Literal
  | ResourceRef
  | LexicalSenseArgument
  | LexicalSenseBNode
;

LexicalSenseArgument:
  '?' prop=ResourceRef
;

LexicalSenseBNode:
  '!' name=ID
;

LexicalSenseDefinitionCondition:
  subject=LexicalSenseArgument
  predicate=LexicalSenseDefinitionConditionPredicate
;

LexicalSenseDefinitionConditionPredicate:
    LexicalSenseDefinitionConditionPredicateIsA
  | LexicalSenseDefinitionConditionPredicateMarker
  | LexicalSenseDefinitionConditionPredicateOptional
;

LexicalSenseDefinitionConditionPredicateIsA:
  'a' (klass=ResourceRef | klass=ClassExpression)
;

LexicalSenseDefinitionConditionPredicateMarker:
  'marker' lexentry=LexicalEntryComponent
;

LexicalSenseDefinitionConditionPredicateOptional:
  opt='optional'
;


//////// Literals

Literal:
  literal=LiteralExpression dtlang=DTLang?
;

NumericLiteralExpression:
    DateTimeExpression
  | TimeExpression
  | DateExpression
  | DurationExpression
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
;

NumberLiteralExpression:
    DecimalExpression
  | RationalExpression
  | IntegerExpression
;

TemporalLiteralExpression:
    DateTimeExpression
  | TimeExpression
  | DateExpression
  | DurationExpression
;

LiteralExpression:
    DateTimeExpression
  | TimeExpression
  | DateExpression
  | DurationExpression
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
  | BooleanExpression
  | StringExpression
;

// FIXME: These would be great, if we can find a single way to desugar them
RangeExpression:
  RangeExpressionTemporal | RangeExpressionNumber
;

RangeExpressionNumber:
    RangeExpressionDecimal
  | RangeExpressionRational
  | RangeExpressionInteger
;

RangeExpressionTemporal:
    RangeExpressionDateTime
  | RangeExpressionTime
  | RangeExpressionDate
;

RangeExpressionDateTime:
  (lowerOpen='(' | lowerClosed='[') lower=DateTimeExpression? '..' higher=DateTimeExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionTime:
  (lowerOpen='(' | lowerClosed='[') lower=TimeExpression? '..' higher=TimeExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionDate:
  (lowerOpen='(' | lowerClosed='[') lower=DateExpression? '..' higher=DateExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionDecimal:
  (lowerOpen='(' | lowerClosed='[') lower=DecimalExpression? '..' higher=DecimalExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionRational:
  (lowerOpen='(' | lowerClosed='[') lower=RationalExpression? '..' higher=RationalExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionInteger:
  (lowerOpen='(' | lowerClosed='[') lower=IntegerExpression? '..' higher=IntegerExpression? (higherOpen=')' | higherClosed=']')
;

DecimalExpression:
  value=STRICTFLOAT
;

RationalExpression:
  numerator=INT '/' denominator=INT
;

IntegerExpression:
  value=INT
;

BooleanExpression:
  value=BOOL
;

DateExpression:
  value=/(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?/
;

TimeExpression:
  value=/(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?/
;

DateTimeExpression:
  value=/(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?/
;

DurationExpression:
  value=/P(?!$)((\d+Y)|(\d+\.\d+Y$))?((\d+M)|(\d+\.\d+M$))?((\d+W)|(\d+\.\d+W$))?((\d+D)|(\d+\.\d+D$))?(T(?=\d)((\d+H)|(\d+\.\d+H$))?((\d+M)|(\d+\.\d+M$))?(\d+(\.\d+)?S)?)??$/
;

StringExpression:
    value=/(?ms)\"{3}(.*?)\"{3}/
  | value=/(?ms)\'{3}(.*?)\'{3}/
  | value=STRING
  | value=/\'(.*?)\'/
;

DTLang:
    '@' language=LANG
  | '^^' dtype=ResourceRef
  | unit=ResourceRef
;


//////// Lexical declarations

IRI:            // An explicit IRI
  /<([^>]*)>/
;

LANG:           // A language code
  /\w{2,3}(-\w{2,3}(-\w{2,3})?)?/
;

END_OF_OBJ:
  ','
;

END_OF_PROP:
  ';'
;

END_OF_SUBJ:
  '.'?
;

Comment:        // A comment
  /#.*$/
;
