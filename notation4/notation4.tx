Notation4:
  OntologyDecl
;




////// Ontologies

OntologyDecl:
  KW_ENTITY_ONTOLOGY
  name=OntologyName
  (
    (KW_GENERIC_AS prefix=PREFIX)?
    (KW_GENERIC_WITH KW_MODIFIER_PRELUDE ((no_prelude=KW_MODIFIER_HIDDEN) | (prelude=OntologyRef)))?
    (KW_GENERIC_WITH KW_MODIFIER_LANGUAGE default_language=LANG)?
  )#
  (
    END_OF_PROP?
    axioms+=Predicate[';']
  )?
  END_OF_SUBJ
  pragmas*=Pragma
  assertions*=OntologyAssertion
;

OntologyAssertion:
    ClassDecl
  | PropertyDecl
  | AttributeDecl
  | DatatypeDecl
  | ConstantDecl
  | BNodeDecl
  | RuleDecl
  | GraphDecl
  | IndividualDecl
;




////// Pragmas

Pragma:
    ImportPragma
  | KeywordPragma
;

ImportPragma:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_IMPORT
  ontology=OntologyRef
  (KW_GENERIC_AS name=PREFIX)?
  END_OF_SUBJ
;

KeywordPragma:
    KeywordPragmaClass
  | KeywordPragmaProperty
  | KeywordPragmaAttribute
  | KeywordPragmaDatatype
  | KeywordPragmaIndividual
  | KeywordPragmaConstant
;

KeywordPragmaClass:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_CLASS
  entity=ClassRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaProperty:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_PROPERTY
  entity=PropertyRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaAttribute:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_ATTRIBUTE
  entity=AttributeRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaDatatype:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_DATATYPE
  entity=DatatypeRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaIndividual:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_INDIVIDUAL
  entity=IndividualRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaConstant:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_CONSTANT
  entity=ConstantRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;




////// Individuals

IndividualDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_INDIVIDUAL?
  name=IndividualName
  (
    END_OF_PROP?
    axioms+=IndividualAxiom[';']
  )?
  END_OF_SUBJ
;

IndividualAxiom:
    IndividualAxiomInstanceOf
  | Predicate
;

IndividualAxiomInstanceOf:
  KW_OPERATOR_INSTANCEOF
  expression=ClassExpression
;



////// BNodes

BNodeDecl:
  '['
    (KW_MODIFIER_LABEL name=BNodeName)?
    (
      END_OF_SUBJ
      axioms+=BNodeAxiom[';']
    )?
  ']'
;

BNodeAxiom:
  Predicate
;



////// Graphs

GraphDecl:
  '{'
    (
      KW_MODIFIER_LABEL name=GraphName
      (
        END_OF_PROP
        axioms+=GraphAxiom[';']
        END_OF_SUBJ
      )?
    )?
    assertions*=GraphAssertion
  '}'
;

GraphAxiom:
  Predicate
;

GraphAssertion:
    ClassDecl
  | PropertyDecl
  | AttributeDecl
  | DatatypeDecl
  | BNodeDecl
  | RuleDecl
  | GraphDecl
  | IndividualDecl
;



////// Formulas

Formula:
  '{'
    assertions*=FormulaAssertion
  '}'
;

FormulaAssertion:
    ClassDecl
  | PropertyDecl
  | AttributeDecl
  | DatatypeDecl
  | BNodeDecl
  | RuleDecl
  | GraphDecl
  | IndividualDecl
;




////// Rules

RuleDecl:
    ForwardRuleDecl
  | BackwardRuleDecl
;

ForwardRuleDecl:
  consequent=Formula
  '<=='
  antecedent=Formula
;

BackwardRuleDecl:
  consequent=Formula
  '<--'
  antecedent=Formula
;




////// Classes

ClassDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_CLASS
  name=ClassName
  (
    END_OF_PROP?
    axioms+=ClassAxiom[';']
  )?
  END_OF_SUBJ
;

ClassAxiom:
    ClassAxiomSpecializes
  | ClassAxiomEquivalence
  | ClassAxiomInstanceOf
  | Predicate
;

ClassAxiomSpecializes:
  KW_OPERATOR_SPECIALIZES
  expression=ClassExpression
;

ClassAxiomEquivalence:
  KW_OPERATOR_EQUIVALENCE
  expression=ClassExpression
;

ClassAxiomInstanceOf:
  KW_OPERATOR_INSTANCEOF
  expression=ClassExpression
;




////// Properties

PropertyDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PROPERTY
  name=PropertyName
  (
    END_OF_PROP?
    axioms+=PropertyAxiom[';']
  )?
  END_OF_SUBJ
;

PropertyAxiom:
    PropertyAxiomSpecializes
  | PropertyAxiomEquivalence
  | PropertyAxiomInstanceOf
  | Predicate
;

PropertyAxiomSpecializes:
  KW_OPERATOR_SPECIALIZES
  expression=PropertyExpressionDisjoint
;

PropertyAxiomEquivalence:
  KW_OPERATOR_EQUIVALENCE
  expression=PropertyExpressionDisjoint
;

PropertyAxiomInstanceOf:
  KW_OPERATOR_INSTANCEOF
  expression=PropertyExpressionDisjoint
;




////// Attributes

AttributeDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_ATTRIBUTE
  name=AttributeName
  (
    END_OF_PROP?
    axioms+=AttributeAxiom[';']
  )?
  END_OF_SUBJ
;

AttributeAxiom:
    AttributeAxiomSpecializes
  | AttributeAxiomEquivalence
  | AttributeAxiomInstanceOf
  | Predicate
;

AttributeAxiomSpecializes:
  KW_OPERATOR_SPECIALIZES
  expression=AttributeExpressionDisjoint
;

AttributeAxiomEquivalence:
  KW_OPERATOR_EQUIVALENCE
  expression=AttributeExpressionDisjoint
;

AttributeAxiomInstanceOf:
  KW_OPERATOR_INSTANCEOF
  expression=AttributeExpressionDisjoint
;



////// Datatypes

DatatypeDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_DATATYPE
  name=DatatypeName
  (
    END_OF_PROP?
    axioms+=DatatypeAxiom[';']
  )?
  END_OF_SUBJ
;

DatatypeAxiom:
    DatatypeAxiomSpecializes
  | Predicate
;

DatatypeAxiomSpecializes:
  KW_OPERATOR_SPECIALIZES
  expression=DataExpression
;




////// Constants

ConstantDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_CONSTANT
  name=ConstantName
  value=Literal
  (
    END_OF_PROP?
    axioms+=ConstantAxiom[';']
  )?
  END_OF_SUBJ
;

ConstantAxiom:
  Predicate
;




////// Class expressions

ClassExpression:
  ClassExpressionDisjoint
;

ClassExpressionDisjoint:
    ClassExpressionDisjunction
  | ClassExpressionConjoint
;

ClassExpressionDisjunction:
  disjuncts=ClassExpressionConjoint KW_EXPRESSION_DISJUNCTION disjuncts+=ClassExpressionConjoint['or']
;

ClassExpressionConjoint:
    ClassExpressionBase
  | ClassExpressionConjunction
  | ClassExpressionPrimary
;

ClassExpressionBase:
  (KW_EXPRESSION_SOMETHING | base_class=ClassRef)
  KW_EXPRESSION_THAT 
  restriction=ClassExpressionConjoint 
  (KW_EXPRESSION_IF condition=ClassExpressionPrimary)?
;

ClassExpressionConjunction:
  conjuncts=ClassExpressionPrimary KW_EXPRESSION_CONJUNCTION conjuncts+=ClassExpressionPrimary['and']
;

ClassExpressionPrimary:
    ClassExpressionComplement
  | ClassExpressionAtom
;

ClassExpressionComplement:
  KW_EXPRESSION_COMPLEMENT expression=ClassExpressionAtom
;

ClassExpressionAtom:
  ClassExpressionRestriction | ('(' ClassExpression ')') | ClassRef
;

ClassExpressionRestriction:
    ClassExpressionAttributeMaxCard
  | ClassExpressionPropertyMaxCard
  | ClassExpressionAttributeMinCard
  | ClassExpressionPropertyMinCard
  | ClassExpressionAttributeExactCard
  | ClassExpressionPropertyExactCard
  | ClassExpressionAttributeOnlySome
  | ClassExpressionPropertyOnlySome
  | ClassExpressionAttributeOnly
  | ClassExpressionPropertyOnly
  | ClassExpressionAttributeSome
  | ClassExpressionPropertySome
  | ClassExpressionAttributeValue
  | ClassExpressionPropertyValue
  | ClassExpressionSelf
;

ClassExpressionAttributeMaxCard[noskipws]:
  /\s*/ role=RestrictedAttributeRole /\s+/ KW_EXPRESSION_AT KW_EXPRESSION_MAXCARD cardinality=INT /\s+/ restriction=RestrictedDataExpression
;

ClassExpressionPropertyMaxCard[noskipws]:
  /\s*/ role=RestrictedPropertyRole /\s+/ KW_EXPRESSION_AT KW_EXPRESSION_MAXCARD cardinality=INT /\s+/ restriction=RestrictedClassExpression
;

ClassExpressionAttributeMinCard[noskipws]:
  /\s*/ role=RestrictedAttributeRole /\s+/ KW_EXPRESSION_AT KW_EXPRESSION_MINCARD cardinality=INT /\s+/ restriction=RestrictedDataExpression
;

ClassExpressionPropertyMinCard[noskipws]:
  /\s*/ role=RestrictedPropertyRole /\s+/ KW_EXPRESSION_AT KW_EXPRESSION_MINCARD cardinality=INT /\s+/ restriction=RestrictedClassExpression
;

ClassExpressionAttributeExactCard[noskipws]:
  /\s*/ role=RestrictedAttributeRole /\s+/ KW_EXPRESSION_EXACTCARD cardinality=INT /\s+/ restriction=RestrictedDataExpression
;

ClassExpressionPropertyExactCard[noskipws]:
  /\s*/ role=RestrictedPropertyRole /\s+/ KW_EXPRESSION_EXACTCARD cardinality=INT /\s+/ restriction=RestrictedClassExpression
;

ClassExpressionAttributeOnlySome[noskipws]:
  /\s*/ role=RestrictedAttributeRole /\s+/ KW_EXPRESSION_ONLY KW_EXPRESSION_SOME restriction=RestrictedDataExpression
;

ClassExpressionPropertyOnlySome[noskipws]:
  /\s*/ role=RestrictedPropertyRole /\s+/ KW_EXPRESSION_ONLY KW_EXPRESSION_SOME restriction=RestrictedClassExpression
;

ClassExpressionAttributeOnly[noskipws]:
  /\s*/ role=RestrictedAttributeRole /\s+/ KW_EXPRESSION_ONLY restriction=RestrictedDataExpression
;

ClassExpressionPropertyOnly[noskipws]:
  /\s*/ role=RestrictedPropertyRole /\s+/ KW_EXPRESSION_ONLY restriction=RestrictedClassExpression
;

ClassExpressionAttributeSome[noskipws]:
  /\s*/ role=RestrictedAttributeRole /\s+/ KW_EXPRESSION_SOME restriction=RestrictedDataExpression
;

ClassExpressionPropertySome[noskipws]:
  /\s*/ role=RestrictedPropertyRole /\s+/ KW_EXPRESSION_SOME restriction=RestrictedClassExpression
;

ClassExpressionAttributeValue[noskipws]:
  /\s*/ role=RestrictedAttributeRole /\s+/ KW_EXPRESSION_IS restriction=AttributeValueRestriction
;

ClassExpressionPropertyValue[noskipws]:
  /\s*/ role=RestrictedPropertyRole /\s+/ KW_EXPRESSION_IS restriction=PropertyValueRestriction
;

ClassExpressionSelf[noskipws]:
  /\s*/ role=RestrictedPropertyRole /\s+/ KW_EXPRESSION_SELF
;

RestrictedAttributeRole[skipws]:
  AttributeExpression
;

RestrictedPropertyRole[skipws]:
  PropertyExpression
;

RestrictedClassExpression[skipws]:
  ClassExpressionAtom
;

RestrictedDataExpression[skipws]:
  DataExpressionAtom
;




////// Property expressions

PropertyExpression:
  (
    left_plural=ExpressionPlural expression=PropertyExpressionDisjoint
  )
  |
  (
    expression=PropertyExpressionDisjoint right_plural=ExpressionPlural?
  )
;

PropertyExpressionDisjoint:
    PropertyExpressionDisjunction
  | PropertyExpressionConjoint
;

PropertyExpressionDisjunction:
  disjuncts=PropertyExpressionConjoint KW_EXPRESSION_DISJUNCTION disjuncts+=PropertyExpressionConjoint['or']
;

PropertyExpressionConjoint:
    PropertyExpressionConjunction
  | PropertyExpressionPrimary
;

PropertyExpressionConjunction:
  conjuncts=PropertyExpressionPrimary KW_EXPRESSION_CONJUNCTION conjuncts+=PropertyExpressionPrimary['and']
;

PropertyExpressionPrimary:
    PropertyExpressionComplement
  | PropertyExpressionChain1
;

PropertyExpressionComplement:
  KW_EXPRESSION_COMPLEMENT expression=PropertyExpressionChain1
;

PropertyExpressionChain1:
    PropertyExpressionChain
  | PropertyExpressionAtom
;

PropertyExpressionChain:
  steps=PropertyExpressionAtom KW_GENERIC_OF steps+=PropertyExpressionAtom['of']
;

PropertyExpressionAtom:
    PropertyExpressionTop 
  | PropertyExpressionBottom
  | PropertyExpressionProduct
  | PropertyExpressionInverse
  | ('(' PropertyExpression ')')
  | PropertyRef
;

PropertyExpressionTop:
  expression=KW_EXPRESSION_SOMETHING
;

PropertyExpressionBottom:
  expression=KW_EXPRESSION_NOTHING
;

PropertyExpressionProduct:
  ((KW_GENERIC_FROM domain=ClassExpressionAtom)? (KW_GENERIC_TO range=ClassExpressionAtom)?)#
;

PropertyExpressionInverse:
  KW_EXPRESSION_INVERSE KW_GENERIC_OF expression=PropertyExpressionAtom
;



////// Plurality quantification

ExpressionPlural:
    PluralCumulative
  | PluralDistributive
;

PluralCumulative: op=KW_EXPRESSION_CUMULATIVE;
PluralDistributive: op=KW_EXPRESSION_DISTRIBUTIVE;




////// Attribute expressions

AttributeExpression:
    left_plural=ExpressionPlural? KW_EXPRESSION_VALUE KW_GENERIC_OF expression=AttributeExpressionDisjoint (KW_GENERIC_OF property=PropertyExpression)?
;

AttributeExpressionDisjoint:
    AttributeExpressionDisjunction
  | AttributeExpressionConjoint
;

AttributeExpressionDisjunction:
  disjuncts=AttributeExpressionConjoint KW_EXPRESSION_DISJUNCTION disjuncts+=AttributeExpressionConjoint['or']
;

AttributeExpressionConjoint:
    AttributeExpressionConjunction
  | AttributeExpressionPrimary
;

AttributeExpressionConjunction:
  conjuncts=AttributeExpressionPrimary KW_EXPRESSION_CONJUNCTION conjuncts+=AttributeExpressionPrimary['and']
;

AttributeExpressionPrimary:
    AttributeExpressionComplement
  | AttributeExpressionAtom
;

AttributeExpressionComplement:
  KW_EXPRESSION_COMPLEMENT expression=AttributeExpressionAtom
;

AttributeExpressionAtom:
    AttributeExpressionTop 
  | AttributeExpressionBottom
  | AttributeExpressionProduct
  | AttributeExpressionInverse
  | ('(' AttributeExpressionDisjoint ')')
  | AttributeRef
;

AttributeExpressionTop:
  expression=KW_EXPRESSION_SOMETHING
;

AttributeExpressionBottom:
  expression=KW_EXPRESSION_NOTHING
;

AttributeExpressionProduct:
  ((KW_GENERIC_FROM domain=ClassExpressionAtom)? (KW_GENERIC_TO range=DataExpressionAtom)?)#
;

AttributeExpressionInverse:
  KW_EXPRESSION_INVERSE KW_GENERIC_OF expression=AttributeExpressionAtom
;



////// Data expressions

DataExpression:
  DataExpressionDisjoint
;

DataExpressionDisjoint:
    DataExpressionDisjunction
  | DataExpressionConjoint
;

DataExpressionDisjunction:
  disjuncts=DataExpressionConjoint KW_EXPRESSION_DISJUNCTION disjuncts+=DataExpressionConjoint['or']
;

DataExpressionConjoint:
    DataExpressionConjunction
  | DataExpressionPrimary
;

DataExpressionConjunction:
  conjuncts=DataExpressionPrimary KW_EXPRESSION_CONJUNCTION conjuncts+=DataExpressionPrimary['and']
;

DataExpressionPrimary:
    DataExpressionComplement
  | DataExpressionAtom
;

DataExpressionComplement:
  KW_EXPRESSION_COMPLEMENT expression=DataExpressionAtom
;

DataExpressionAtom:
  DataExpressionTop | DataFacet | ('(' DataExpression ')') | DatatypeRef
;

DataExpressionTop: KW_EXPRESSION_SOMETHING;

DataFacet:
    DataFacetGTE
  | DataFacetGT
  | DataFacetLTE
  | DataFacetLT
  | DataFacetEq
  | DataFacetMinLengthInclusive
  | DataFacetMinLengthExclusive
  | DataFacetMaxLengthInclusive
  | DataFacetMaxLengthExclusive
  | DataFacetMatches
;

DataFacetGTE: KW_OPERATOR_GTE value=NumericLiteralExpression;
DataFacetGT: KW_OPERATOR_GT value=NumericLiteralExpression;
DataFacetLTE: KW_OPERATOR_LTE value=NumericLiteralExpression;
DataFacetLT: KW_OPERATOR_LT value=NumericLiteralExpression;
DataFacetEq: KW_OPERATOR_EQ value=NumericLiteralExpression;
DataFacetMinLengthInclusive: KW_OPERATOR_LENGTH KW_OPERATOR_GTE value=INT;
DataFacetMinLengthExclusive: KW_OPERATOR_LENGTH KW_OPERATOR_GT value=INT;
DataFacetMaxLengthInclusive: KW_OPERATOR_LENGTH KW_OPERATOR_LTE value=INT;
DataFacetMaxLengthExclusive: KW_OPERATOR_LENGTH KW_OPERATOR_LT value=INT;
DataFacetMatches: KW_OPERATOR_MATCHES value=StringLiteralExpression;




////// Value restrictions

AttributeValueRestriction[skipws]:
    NominalAttributeRestriction
  | AttributeValueUniversalVar
  | LiteralExpression
;

AttributeValueUniversalVar:
  universal_var=UNIVAR
;

PropertyValueRestriction[skipws]:
    NominalPropertyRestriction
  | IndividualRef
;

NominalAttributeRestriction[skipws]:
  KW_GENERIC_THE KW_EXPRESSION_VALUE KW_GENERIC_OF expression=AttributeExpressionDisjoint is_local?=NominalRestrictionLocal
;

NominalPropertyRestriction[skipws]:
  KW_GENERIC_THE expression=PropertyExpression is_local?=NominalRestrictionLocal
;

NominalRestrictionLocal:
  KW_GENERIC_OF KW_GENERIC_IT
;




////// Infix expressions

InfixExpression:
  InfixAdd
;

InfixAdd:
    InfixAdditive
  | InfixMult
;

InfixAdditive:
  operands=InfixMult operator=KW_INFIX_ADDITIVE operands=InfixAdd
;

InfixMult:
    InfixMultiplicative
  | InfixExp
;

InfixMultiplicative:
  operands=InfixExp operator=KW_INFIX_MULTIPLICATIVE operands=InfixMult
;

InfixExp:
    InfixExponential
  | InfixNumericAtom
;

InfixExponential:
  operands=InfixNumericAtom operator=KW_INFIX_EXPONENTIAL operands=InfixExp
;

InfixNumericAtom:
  AttributeValueUniversalVar | ConstantRef | NumericLiteralExpression | '(' InfixExpression ')' 
;




////// Predicates

Predicate:
  (property=BuiltinPredicate | property=PredicateRef)
  objects+=PropertyObject[',']
;

PropertyObject:
    BNodeDecl
  | GraphDecl
  | HeadedList
  | Collection
  | InfixExpression
  | ObjectRef
  | Literal
;

BuiltinPredicate:
    LogicalIdenticalPredicate
  | LogicalDifferentPredicate
  | NumericEqualsPredicate
  | NumericNotEqualsPredicate
  | NumericLessThanEqualsPredicate
  | NumericLessThanPredicate
  | NumericGreaterThanEqualsPredicate
  | NumericGreaterThanPredicate
  | LogicalEqualsPredicate
  | LogicalNotEqualsPredicate
  | LogicalSemanticsPredicate
  | LogicalConclusionsPredicate
  | CollectionInclusionPredicate
;

LogicalEqualsPredicate: op='= ';
LogicalNotEqualsPredicate: op='=/= ';
NumericEqualsPredicate: op='== ';
NumericNotEqualsPredicate: op='!= ';
NumericLessThanEqualsPredicate: op='<= ';
NumericLessThanPredicate: op='< ';
NumericGreaterThanEqualsPredicate: op='>= ';
NumericGreaterThanPredicate: op='> ';
LogicalSemanticsPredicate: op='|- ';
LogicalConclusionsPredicate: op='|= ';
LogicalIdenticalPredicate: op='=== ';
LogicalDifferentPredicate: op='!== ';
CollectionInclusionPredicate: op='in ';




////// Collections

HeadedList:
  head=PredicateRef '(' members*=HeadedListObject[','] ')'
;

HeadedListObject:
    BNodeDecl
  | GraphDecl
  | HeadedList
  | Collection
  | InfixExpression
  | ObjectRef
  | Literal
;

Collection:
  (collection_type=CollectionType)? '(' members+=PropertyObject[','] ')'
;

CollectionType:
    CollectionTypeBag
  | CollectionTypeSet
  | CollectionTypeAlts
  | CollectionTypeSeq
;

CollectionTypeBag: type=KW_COLLECTIONTYPE_BAG;
CollectionTypeSet: type=KW_COLLECTIONTYPE_SET;
CollectionTypeAlts: type=KW_COLLECTIONTYPE_ALTS;
CollectionTypeSeq: type=KW_COLLECTIONTYPE_SEQ;




////// References

GeneralName: IRI | QNAME | UNIVAR | EXIVAR;

OntologyName:
  IRI
;

OntologyRef:
  ref=[OntologyDecl|IRI] (KW_GENERIC_FROM local_file=STRING)?
;

KeywordName: LOCALNAME;

KeywordRef:
  ref=[KeywordPragma|LOCALNAME]
;

IndividualName: GeneralName;

IndividualRef:
  ref=[IndividualDecl|IRI] | ref=[IndividualDecl|QNAME]
;

BNodeName: GeneralName;

BNodeRef:
  ref=[BNodeDecl|IRI] | ref=[BNodeDecl|QNAME]
;

GraphName: GeneralName;

GraphRef:
  ref=[GraphDecl|IRI] | ref=[GraphDecl|QNAME]
;

ClassName: GeneralName;

ClassRef:
  ref=[ClassDecl|IRI] | ref=[ClassDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

PropertyName: GeneralName;

PropertyRef:
  ref=[PropertyDecl|IRI] | ref=[PropertyDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

AttributeName: GeneralName;

AttributeRef:
  ref=[AttributeDecl|IRI] | ref=[AttributeDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

PredicateRef:
  ref=[PropertyDecl|IRI] | ref=[PropertyDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

ObjectRef:
  ref=[IndividualDecl|IRI] | ref=[IndividualDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

DatatypeName: GeneralName;

DatatypeRef:
  ref=[DatatypeDecl|IRI] | ref=[DatatypeDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

ConstantName: GeneralName;

ConstantRef:
  ref=[ConstantDecl|IRI] | ref=[ConstantDecl|QNAME]
;




////// Keywords

KW:
    KW_ENTITY
  | KW_PRAGMA
  | KW_COLLECTIONTYPE
  | KW_GENERIC
  | KW_MODIFIER
  | KW_OPERATOR
  | KW_EXPRESSION
  | KW_INFIX
;

KW_ENTITY:
    KW_ENTITY_ATTRIBUTE
  | KW_ENTITY_CLASS
  | KW_ENTITY_CONSTANT
  | KW_ENTITY_DATATYPE
  | KW_ENTITY_INDIVIDUAL
  | KW_ENTITY_ONTOLOGY
  | KW_ENTITY_PROPERTY
;

KW_ENTITY_ATTRIBUTE: 'attribute ';
KW_ENTITY_CLASS: 'class ';
KW_ENTITY_CONSTANT: 'constant ';
KW_ENTITY_DATATYPE: 'datatype ';
KW_ENTITY_INDIVIDUAL: 'individual ';
KW_ENTITY_ONTOLOGY: 'ontology ';
KW_ENTITY_PROPERTY: 'property ';


KW_PRAGMA:
    KW_PRAGMA_IMPORT
  | KW_PRAGMA_KEYWORD
;

KW_PRAGMA_IMPORT: 'import ';
KW_PRAGMA_KEYWORD: 'keyword ';


KW_COLLECTIONTYPE:
    KW_COLLECTIONTYPE_ALTS
  | KW_COLLECTIONTYPE_BAG
  | KW_COLLECTIONTYPE_SEQ
  | KW_COLLECTIONTYPE_SET
;

KW_COLLECTIONTYPE_ALTS: '@alts';
KW_COLLECTIONTYPE_BAG: '@bag';
KW_COLLECTIONTYPE_SEQ: '@seq';
KW_COLLECTIONTYPE_SET: '@set';


KW_GENERIC:
    KW_GENERIC_AS
  | KW_GENERIC_FROM
  | KW_GENERIC_IT
  | KW_GENERIC_OF
  | KW_GENERIC_THE
  | KW_GENERIC_TO
  | KW_GENERIC_WITH
;

KW_GENERIC_AS: 'as ';
KW_GENERIC_FROM: 'from ';
KW_GENERIC_IT: 'it ';
KW_GENERIC_OF: 'of ';
KW_GENERIC_THE: 'the ';
KW_GENERIC_TO: 'to ';
KW_GENERIC_WITH: 'with ';


KW_MODIFIER:
    KW_MODIFIER_EXPORTED
  | KW_MODIFIER_HIDDEN
  | KW_MODIFIER_LABEL
  | KW_MODIFIER_LANGUAGE
  | KW_MODIFIER_PRELUDE
;

KW_MODIFIER_EXPORTED: 'exported ';
KW_MODIFIER_HIDDEN: 'hidden ';
KW_MODIFIER_LABEL: ':- ';
KW_MODIFIER_LANGUAGE: 'language ';
KW_MODIFIER_PRELUDE: 'prelude ';


KW_OPERATOR:
    KW_OPERATOR_EQUIVALENCE
  | KW_OPERATOR_INSTANCEOF
  | KW_OPERATOR_SPECIALIZES
  | KW_OPERATOR_LTE
  | KW_OPERATOR_LT
  | KW_OPERATOR_GTE
  | KW_OPERATOR_GT
  | KW_OPERATOR_EQ
  | KW_OPERATOR_LENGTH
  | KW_OPERATOR_MATCHES
;

KW_OPERATOR_EQUIVALENCE: '~= ';
KW_OPERATOR_INSTANCEOF: 'a ';
KW_OPERATOR_SPECIALIZES: '<| ';
KW_OPERATOR_LTE: '<= ';
KW_OPERATOR_LT: '< ';
KW_OPERATOR_GTE: '>= ';
KW_OPERATOR_GT: '> ';
KW_OPERATOR_EQ: '= ';
KW_OPERATOR_LENGTH: 'length ';
KW_OPERATOR_MATCHES: 'matches ';


KW_EXPRESSION:
    KW_EXPRESSION_AT
  | KW_EXPRESSION_COMPLEMENT
  | KW_EXPRESSION_CONJUNCTION
  | KW_EXPRESSION_CUMULATIVE
  | KW_EXPRESSION_DISJUNCTION
  | KW_EXPRESSION_DISTRIBUTIVE
  | KW_EXPRESSION_EXACTCARD
  | KW_EXPRESSION_IF
  | KW_EXPRESSION_INVERSE
  | KW_EXPRESSION_IS
  | KW_EXPRESSION_MAXCARD
  | KW_EXPRESSION_MINCARD
  | KW_EXPRESSION_NOTHING
  | KW_EXPRESSION_ONLY
  | KW_EXPRESSION_SELF
  | KW_EXPRESSION_SOMETHING
  | KW_EXPRESSION_SOME
  | KW_EXPRESSION_THAT
  | KW_EXPRESSION_VALUE
;

KW_EXPRESSION_AT: 'at ';
KW_EXPRESSION_COMPLEMENT: 'not ';
KW_EXPRESSION_CONJUNCTION: 'and ';
KW_EXPRESSION_CUMULATIVE: 'variously ';
KW_EXPRESSION_DISJUNCTION: 'or ';
KW_EXPRESSION_DISTRIBUTIVE: 'separately ';
KW_EXPRESSION_EXACTCARD: 'exactly ';
KW_EXPRESSION_IF: 'if ';
KW_EXPRESSION_INVERSE: 'inverse ';
KW_EXPRESSION_IS: 'is ';
KW_EXPRESSION_MAXCARD: 'most ';
KW_EXPRESSION_MINCARD: 'least ';
KW_EXPRESSION_NOTHING: 'nothing ';
KW_EXPRESSION_ONLY: 'only ';
KW_EXPRESSION_SELF: 'itself ';
KW_EXPRESSION_SOMETHING: 'something ';
KW_EXPRESSION_SOME: 'a ';
KW_EXPRESSION_THAT: 'that '|'where ';
KW_EXPRESSION_VALUE: 'value ';

KW_INFIX:
    KW_INFIX_ADDITIVE
  | KW_INFIX_MULTIPLICATIVE
  | KW_INFIX_EXPONENTIAL
;

KW_INFIX_ADDITIVE:
  KW_INFIX_ADDITIVE_PLUS | KW_INFIX_ADDITIVE_MINUS
;

KW_INFIX_ADDITIVE_PLUS:
  op='+'
;

KW_INFIX_ADDITIVE_MINUS:
  op='-'
;

KW_INFIX_MULTIPLICATIVE:
  KW_INFIX_MULTIPLICATIVE_TIMES | KW_INFIX_MULTIPLICATIVE_DIVIDE
;

KW_INFIX_MULTIPLICATIVE_TIMES:
  op='*'
;

KW_INFIX_MULTIPLICATIVE_DIVIDE:
  op='/'
;

KW_INFIX_EXPONENTIAL:
  op='^'
;



////// Literals

Literal:
  literal=LiteralExpression dtlang=DTLang?
;

NumericLiteralExpression:
    DateTimeExpression
  | DurationExpression
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
;

NumberLiteralExpression:
    DecimalExpression
  | RationalExpression
  | IntegerExpression
;

TemporalLiteralExpression:
    DateTimeExpression
  | DurationExpression
;

LiteralExpression:
    DateTimeExpression
  | DurationExpression
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
  | BooleanExpression
  | RegexExpression
  | StringExpression
;

RangeExpression:
  RangeExpressionTemporal | RangeExpressionNumber
;

RangeExpressionNumber:
    RangeExpressionDecimal
  | RangeExpressionRational
  | RangeExpressionInteger
;

RangeExpressionTemporal:
    RangeExpressionDateTime
;

RangeExpressionDateTime:
  (lowerOpen='(' | lowerClosed='[') lower=DateTimeExpression? '..' higher=DateTimeExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionDecimal:
  (lowerOpen='(' | lowerClosed='[') lower=DecimalExpression? '..' higher=DecimalExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionRational:
  (lowerOpen='(' | lowerClosed='[') lower=RationalExpression? '..' higher=RationalExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionInteger:
  (lowerOpen='(' | lowerClosed='[') lower=IntegerExpression? '..' higher=IntegerExpression? (higherOpen=')' | higherClosed=']')
;

DecimalExpression:
  value=STRICTFLOAT
;

RationalExpression:
  numerator=INT '/' denominator=INT
;

IntegerExpression:
  value=INT
;

BooleanExpression:
  value=BOOL
;

DateTimeExpression:
  value=/(?:[\+-]?\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[\.,]\d+(?!:))?)?(?:\2[0-5]\d(?:[\.,]\d+)?)?(?:[zZ]|(?:[\+-])(?:[01]\d|2[0-3]):?(?:[0-5]\d)?)?)?)?/
;

DurationExpression:
  value=/(-?)P(?=\d|T\d)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)([DW]))?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?/
  //value=/^P(?!$)((\d+Y)|(\d+\.\d+Y$))?((\d+M)|(\d+\.\d+M$))?((\d+W)|(\d+\.\d+W$))?((\d+D)|(\d+\.\d+D$))?(T(?=\d)((\d+H)|(\d+\.\d+H$))?((\d+M)|(\d+\.\d+M$))?(\d+(\.\d+)?S)?)??$/
;

StringLiteralExpression:
    RegexExpression
  | StringExpression
;

RegexExpression:
  value=/(\/.*\/)/
;

StringExpression:
    value=/(?ms)\"{3}(.*?)\"{3}/
  | value=/(?ms)\'{3}(.*?)\'{3}/
  | value=STRING
  | value=/\'(.*?)\'/
;

DTLang:
    '@' language=LANG
  | '^^' data_type=DatatypeRef
  | unit=IndividualRef
;




////// Lexer

IRI:
  /(<[^>\s]*>)/
;

QNAME:
  !KW /(([A-Za-z_\-][A-Za-z0-9_\-]*\:)?([A-Za-z_\-][A-Za-z0-9_\-]*))/
;

PREFIX:
  /([A-Za-z_\-][A-Za-z0-9_\-]*)/
;

LOCALNAME:
  /([A-Za-z_\-][A-Za-z0-9_\-]*)/
;

UNIVAR:
  /\?([A-Za-z_\-][A-Za-z0-9_\-]*)/
;

EXIVAR:
  /\!([A-Za-z_\-][A-Za-z0-9_\-]*)/
;

LANG:
  /\w{2,3}(-\w{2,3}(-\w{2,3})?)?/
;

END_OF_OBJ:
  ','
;

END_OF_PROP:
  ';'
;

END_OF_SUBJ:
  '.'
;

Comment:
  /#.*$/
;