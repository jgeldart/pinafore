Notation4:
  OntologyDecl
;




////// Ontologies

OntologyDecl:
  KW_ENTITY_ONTOLOGY
  name=OntologyName
  (
    (KW_GENERIC_AS prefix=PREFIX)?
    (KW_GENERIC_WITH KW_MODIFIER_PRELUDE ((no_prelude=KW_MODIFIER_HIDDEN) | (prelude=OntologyRef)))?
    (KW_GENERIC_WITH KW_MODIFIER_LANGUAGE default_language=LANG)?
  )#
  (
    END_OF_PROP?
    axioms+=Predicate[';']
  )?
  END_OF_SUBJ
  pragmas*=Pragma
  assertions*=OntologyAssertion
;

OntologyAssertion:
    ClassDecl
  | PropertyDecl
  | AttributeDecl
  | DatatypeDecl
  | ConstantDecl
  | ClassPatternDecl
  | PropertyPatternDecl
  | AttributePatternDecl
  | DatatypePatternDecl
  | IndividualPatternDecl
  | ModalPatternDecl
  | LiteralPatternDecl
  | PropertyRestrictionPatternDecl
  | AttributeRestrictionPatternDecl
  | BNodeDecl
  | RuleDecl
  | GraphDecl
  | IndividualDecl
;




////// Pragmas

Pragma:
    ImportPragma
  | KeywordPragma
;

ImportPragma:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_IMPORT
  ontology=OntologyRef
  (KW_GENERIC_AS name=PREFIX)?
  END_OF_SUBJ
;

KeywordPragma:
    KeywordPragmaClass
  | KeywordPragmaProperty
  | KeywordPragmaAttribute
  | KeywordPragmaDatatype
  | KeywordPragmaIndividual
  | KeywordPragmaConstant
;

KeywordPragmaClass:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_CLASS
  entity=ClassRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaProperty:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_PROPERTY
  entity=PropertyRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaAttribute:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_ATTRIBUTE
  entity=AttributeRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaDatatype:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_DATATYPE
  entity=DatatypeRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaIndividual:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_INDIVIDUAL
  entity=IndividualRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;

KeywordPragmaConstant:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_PRAGMA_KEYWORD
  KW_ENTITY_CONSTANT
  entity=ConstantRef
  KW_GENERIC_AS
  name=KeywordName
  END_OF_SUBJ
;



////// Patterns

ClassPatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_CLASS
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  (
    KW_MODIFIER_RETURNING
    returns+=PatternReturn
  )?
  unifier=Formula
  (repeater=Formula
    ( KW_OPERATOR_BACKWARDCHAIN
      antecedent=Formula
    )?
  )?
  (
    END_OF_PROP?
    axioms+=ClassPatternAxiom[';']
  )?
  END_OF_SUBJ
;

ClassPatternAxiom:
  Predicate
;

PropertyPatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_PROPERTY
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  (
    KW_MODIFIER_RETURNING
    returns+=PatternReturn
  )?
  unifier=Formula
  (repeater=Formula
    ( KW_OPERATOR_BACKWARDCHAIN
      antecedent=Formula
    )?
  )?
  (
    END_OF_PROP?
    axioms+=PropertyPatternAxiom[';']
  )?
  END_OF_SUBJ
;

PropertyPatternAxiom:
  Predicate
;

AttributePatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_ATTRIBUTE
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  (
    KW_MODIFIER_RETURNING
    returns+=PatternReturn
  )?
  unifier=Formula
  (repeater=Formula
    ( KW_OPERATOR_BACKWARDCHAIN
      antecedent=Formula
    )?
  )?
  (
    END_OF_PROP?
    axioms+=AttributePatternAxiom[';']
  )?
  END_OF_SUBJ
;

AttributePatternAxiom:
  Predicate
;

DatatypePatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_DATATYPE
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  (
    KW_MODIFIER_RETURNING
    returns+=PatternReturn
  )?
  unifier=Formula
  (repeater=Formula
    ( KW_OPERATOR_BACKWARDCHAIN
      antecedent=Formula
    )?
  )?
  (
    END_OF_PROP?
    axioms+=DatatypePatternAxiom[';']
  )?
  END_OF_SUBJ
;

DatatypePatternAxiom:
  Predicate
;

IndividualPatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_INDIVIDUAL
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  (
    KW_MODIFIER_RETURNING
    returns+=PatternReturn
  )?
  unifier=Formula
  (repeater=Formula
    ( KW_OPERATOR_BACKWARDCHAIN
      antecedent=Formula
    )?
  )?
  (
    END_OF_PROP?
    axioms+=IndividualPatternAxiom[';']
  )?
  END_OF_SUBJ
;

IndividualPatternAxiom:
  Predicate
;

PropertyRestrictionPatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_PROPERTY_RESTRICTION
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  KW_OPERATOR_EQUIVALENCE
  expression=ClassExpression
  (
    END_OF_PROP?
    axioms+=RestrictionPatternAxiom[';']
  )?
  END_OF_SUBJ
;

AttributeRestrictionPatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_ATTRIBUTE_RESTRICTION
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  KW_OPERATOR_EQUIVALENCE
  expression=ClassExpression
  (
    END_OF_PROP?
    axioms+=RestrictionPatternAxiom[';']
  )?
  END_OF_SUBJ
;

RestrictionPatternAxiom:
  Predicate
;

ModalPatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_MODAL
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  KW_OPERATOR_EQUIVALENCE
  expression=ClassExpression
  (
    END_OF_PROP?
    axioms+=ModalPatternAxiom[';']
  )?
  END_OF_SUBJ
;

ModalPatternAxiom:
  Predicate
;

LiteralPatternDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_PATTERN
  KW_ENTITY_LITERAL
  name=PatternName
  args*=PatternArg
  kwargs*=PatternKwarg
  (
    KW_MODIFIER_RETURNING
    returns+=PatternReturn
  )?
  unifier=Formula
  (repeater=Formula
    ( KW_OPERATOR_BACKWARDCHAIN
      antecedent=Formula
    )?
  )?
  (
    END_OF_PROP?
    axioms+=LiteralPatternAxiom[';']
  )?
  END_OF_SUBJ
;

LiteralPatternAxiom:
  Predicate
;

PatternArg:
  name=UNIVAR
;

PatternKwarg:
  KW_GENERIC_WITH name=UNIVAR
;

PatternKwargValue:
  KW_GENERIC_WITH ref=LOCALNAME value=PropertyObject
;

PatternReturn:
  (universal_var=UNIVAR) | (existential_var=EXIVAR)
;




////// Individuals

IndividualDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  (modifiers*=IndividualModifier KW_ENTITY_INDIVIDUAL)?
  (name=IndividualName | subject=IndividualComplexSubject)
  (
    END_OF_PROP?
    axioms+=IndividualAxiom[';']
  )?
  END_OF_SUBJ
;

IndividualModifier:
  pattern=IndividualPatternRef
  ('(' modifier_args+=PropertyObject[','] ')')?
;

IndividualAxiom:
    IndividualAxiomInstanceOf
  | PatternKwargValue
  | Predicate
;

IndividualAxiomInstanceOf:
  KW_OPERATOR_INSTANCEOF
  expression=ClassExpression
;

IndividualComplexSubject:
    BNodeDecl
  | GraphDecl
  | HeadedList
  | Collection
  | ObjectRef
  | InfixExpression
  | Literal
;



////// BNodes

BNodeDecl:
  '['
    (KW_MODIFIER_LABEL name=BNodeName)?
    (
      END_OF_SUBJ
      axioms+=BNodeAxiom[';']
    )?
  ']'
;

BNodeAxiom:
  Predicate
;



////// Graphs

GraphDecl:
  '{'
    (
      KW_MODIFIER_LABEL name=GraphName
      (
        END_OF_PROP
        axioms+=GraphAxiom[';']
        END_OF_SUBJ
      )?
    )?
    assertions*=GraphAssertion
  '}'
;

GraphAxiom:
  Predicate
;

GraphAssertion:
    ClassDecl
  | PropertyDecl
  | AttributeDecl
  | DatatypeDecl
  | BNodeDecl
  | RuleDecl
  | GraphDecl
  | IndividualDecl
;



////// Formulas

Formula:
  '{'
    assertions*=FormulaAssertion
  '}'
;

FormulaAssertion:
    ClassDecl
  | PropertyDecl
  | AttributeDecl
  | DatatypeDecl
  | BNodeDecl
  | RuleDecl
  | GraphDecl
  | IndividualDecl
;




////// Rules

RuleDecl:
    ForwardRuleDecl
  | BackwardRuleDecl
;

ForwardRuleDecl:
  consequent=Formula
  KW_OPERATOR_FORWARDCHAIN
  antecedent=Formula
;

BackwardRuleDecl:
  consequent=Consequent
  KW_OPERATOR_BACKWARDCHAIN
  antecedent=Formula
;

Consequent:
    Formula
  | Fail
;

Fail:
  op=KW_GENERIC_FAILURE
;




////// Classes

ClassDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  modifiers*=ClassModifier
  KW_ENTITY_CLASS
  (name=ClassName | ('(' expression=ClassExpression ')'))
  (
    END_OF_PROP?
    axioms+=ClassAxiom[';']
  )?
  END_OF_SUBJ
;

ClassModifier:
  pattern=ClassPatternRef
  ('(' modifier_args+=PropertyObject[','] ')')?
;

ClassAxiom:
    ClassAxiomSpecializes
  | ClassAxiomEquivalence
  | ClassAxiomInstanceOf
  | ClassAxiomPartitions
  | ClassAxiomHasKey
  | PatternKwargValue
  | Predicate
;

ClassAxiomSpecializes:
  KW_OPERATOR_SPECIALIZES
  expression=ClassExpression
;

ClassAxiomEquivalence:
  KW_OPERATOR_EQUIVALENCE
  expression=ClassExpression
;

ClassAxiomInstanceOf:
  KW_OPERATOR_INSTANCEOF
  expression=ClassExpression
;

ClassAxiomPartitions:
  KW_OPERATOR_PARTITIONS
  classes+=ClassExpression[',']
;

ClassAxiomHasKey:
  KW_OPERATOR_KEY
  keys+=KeyPredicate[',']
;

KeyPredicate:
    (PropertyExpressionDisjoint)
  | (KW_EXPRESSION_VALUE KW_GENERIC_OF AttributeExpressionDisjoint)
;


////// Properties

PropertyDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  modifiers*=PropertyModifier
  KW_ENTITY_PROPERTY
  (name=PropertyName | ('(' expression=PropertyExpressionDisjoint ')'))
  (
    END_OF_PROP?
    axioms+=PropertyAxiom[';']
  )?
  END_OF_SUBJ
;

PropertyModifier:
  pattern=PropertyPatternRef
  ('(' modifier_args+=PropertyObject[','] ')')?
;

PropertyAxiom:
    PropertyAxiomSpecializes
  | PropertyAxiomEquivalence
  | PropertyAxiomInstanceOf
  | PatternKwargValue
  | Predicate
;

PropertyAxiomSpecializes:
  KW_OPERATOR_SPECIALIZES
  expression=PropertyExpressionDisjoint
;

PropertyAxiomEquivalence:
  KW_OPERATOR_EQUIVALENCE
  expression=PropertyExpressionDisjoint
;

PropertyAxiomInstanceOf:
  KW_OPERATOR_INSTANCEOF
  expression=PropertyExpressionDisjoint
;




////// Attributes

AttributeDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  modifiers*=AttributeModifier
  KW_ENTITY_ATTRIBUTE
  (name=AttributeName | ('(' expression=AttributeExpressionDisjoint ')'))
  (
    END_OF_PROP?
    axioms+=AttributeAxiom[';']
  )?
  END_OF_SUBJ
;

AttributeModifier:
  pattern=AttributePatternRef
  ('(' modifier_args+=PropertyObject[','] ')')?
;

AttributeAxiom:
    AttributeAxiomSpecializes
  | AttributeAxiomEquivalence
  | AttributeAxiomInstanceOf
  | PatternKwargValue
  | Predicate
;

AttributeAxiomSpecializes:
  KW_OPERATOR_SPECIALIZES
  expression=AttributeExpressionDisjoint
;

AttributeAxiomEquivalence:
  KW_OPERATOR_EQUIVALENCE
  expression=AttributeExpressionDisjoint
;

AttributeAxiomInstanceOf:
  KW_OPERATOR_INSTANCEOF
  expression=AttributeExpressionDisjoint
;



////// Datatypes

DatatypeDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  modifiers*=DatatypeModifier
  KW_ENTITY_DATATYPE
  name=DatatypeName
  (
    END_OF_PROP?
    axioms+=DatatypeAxiom[';']
  )?
  END_OF_SUBJ
;

DatatypeModifier:
  pattern=DatatypePatternRef
  ('(' modifier_args+=PropertyObject[','] ')')?
;

DatatypeAxiom:
    DatatypeAxiomSpecializes
  | DatatypeAxiomEquivalence
  | PatternKwargValue
  | Predicate
;

DatatypeAxiomSpecializes:
  KW_OPERATOR_SPECIALIZES
  expression=DataExpression
;

DatatypeAxiomEquivalence:
  KW_OPERATOR_EQUIVALENCE
  expression=DataExpression
;




////// Constants

ConstantDecl:
  is_exported?=KW_MODIFIER_EXPORTED
  KW_ENTITY_CONSTANT
  name=ConstantName
  value=Literal
  (
    END_OF_PROP?
    axioms+=ConstantAxiom[';']
  )?
  END_OF_SUBJ
;

ConstantAxiom:
  Predicate
;




////// Class expressions

ClassExpression:
  ClassExpressionModified
;

ClassExpressionModified:
    ClassExpressionModifier
  | ClassExpressionDisjoint
;

ClassExpressionModifier:
    ClassExpressionModalNecessity
  | ClassExpressionModalPossibility
  | ClassExpressionModalInevitable
  | ClassExpressionFuzzyModifier
  | ClassExpressionModalOnce
  | ClassExpressionModalNever
  | ClassExpressionModalRepeat
  | ClassExpressionModalAssumed
  | ClassExpressionModalProven
  | ClassExpressionModalClaimed
  | ClassExpressionModalSTIT
  | ClassExpressionModalObligation
  | ClassExpressionModalPermission
  | ClassExpressionModalProhibition
  | ClassExpressionModalOmission
  | ClassExpressionModalOption
  | ClassExpressionModalPattern
;

// TODO: Fuzzy antonyms?
// TODO: Fuzzy integrals (Choquet and Quasi Sugno)
// TODO: Fuzzy OWAs and q-OWAs
// TODO: Fuzzy rough sets (upper and lower approximations): really, definitely, rather, roughly
// TODO: Power modifiers (f(x) = x^alpha)
// TODO: Alpha cuts for property expressions (>= only)
// TODO: Fuzzy 'a' and '<|' assertions (typically a, typically)
// TODO: Argument modals: support, conflict
// IDEA: Rename 'confidently' to 'perhaps'?
// IDEA: ontology graph metadata
// IDEA: predicate patterns? As repl. for literal patterns

ClassExpressionDisjoint:
    ClassExpressionDisjunction
  | ClassExpressionConjoint
;

ClassExpressionDisjunction:
  disjuncts=ClassExpressionConjoint KW_EXPRESSION_DISJUNCTION disjuncts+=ClassExpressionConjoint['or']
;

ClassExpressionConjoint:
    ClassExpressionBase
  | ClassExpressionConjunction
  | ClassExpressionTemporalDisjoint
;

ClassExpressionBase:
  (KW_EXPRESSION_SOMETHING | base_class=ClassRef)
  KW_EXPRESSION_THAT 
  restriction=ClassExpressionConjoint 
  (KW_EXPRESSION_IF condition=ClassExpressionPrimary)?
;

ClassExpressionConjunction:
  conjuncts=ClassExpressionTemporalDisjoint KW_EXPRESSION_CONJUNCTION conjuncts+=ClassExpressionTemporalDisjoint['and']
;

ClassExpressionTemporalDisjoint:
    ClassExpressionTemporalDisjunction
  | ClassExpressionTemporalConjoint
;

ClassExpressionTemporalDisjunction:
  KW_EXPRESSION_TEMPORAL_DISJUNCTION disjuncts+=ClassExpressionTemporalConjoint['or']
;

ClassExpressionTemporalConjoint:
    ClassExpressionTemporalConjunction
  | ClassExpressionTime
;

ClassExpressionTemporalConjunction:
  KW_EXPRESSION_TEMPORAL_CONJUNCTION conjuncts+=ClassExpressionTime['and']
;

ClassExpressionTime:
    ClassExpressionTemporalChain
  | ClassExpressionFuzz
;

ClassExpressionTemporalChain:
  steps+=ClassExpressionTemporal
;

ClassExpressionTemporal:
    ClassExpressionFutureGlobal
  | ClassExpressionFutureLeadsTo
  | ClassExpressionFutureNext
  | ClassExpressionFutureRelease
  | ClassExpressionFutureUnless
  | ClassExpressionFutureUntil
  | ClassExpressionPastGlobal
  | ClassExpressionPastLeadsTo
  | ClassExpressionPastNext
  | ClassExpressionPastUntil
  | ClassExpressionPastEventual
  | ClassExpressionFutureEventual
;

ClassExpressionFuzz:
    ClassExpressionWeightedSum
  | ClassExpressionPrimary
;

ClassExpressionWeightedSum:
  summands=ClassExpressionWeightedSummand '+' summands+=ClassExpressionWeightedSummand['+']
;

ClassExpressionWeightedSummand:
  weight=INT expression=ClassExpressionPrimary
;

ClassExpressionPrimary:
    ClassExpressionComplement
  | ClassExpressionAtom
;

ClassExpressionComplement:
  KW_EXPRESSION_COMPLEMENT expression=ClassExpressionAtom
;

ClassExpressionAtom:
  ClassExpressionRestriction | ('(' ClassExpression ')') | UniversalVar | ExistentialVar | ClassExpressionTop | ClassExpressionBottom | ClassExpressionRecursion | ClassExpressionConfidence | ClassExpressionEnumeration | ClassRef
;

ClassExpressionTop: expression=KW_EXPRESSION_SOMETHING;
ClassExpressionBottom: expression=KW_EXPRESSION_NOTHING;
ClassExpressionRecursion: expression=KW_EXPRESSION_RECURSION;
ClassExpressionEnumeration: '{' elements*=ClassExpressionEnumerationElement[','] '}';

ClassExpressionEnumerationElement:
    NominalVariable
  | NominalPropertyRestriction
  | ExistentialVar
  | UniversalVar
  | IndividualRef
;

ClassExpressionConfidence:
    ClassExpressionConfidenceAtLeast
  | ClassExpressionConfidenceAtMost
;

ClassExpressionConfidenceAtLeast:
  KW_EXPRESSION_CONFIDENCE KW_EXPRESSION_AT KW_EXPRESSION_MIN degree=FUZZY_DEGREE expression=ClassExpressionAtom
;

ClassExpressionConfidenceAtMost:
  KW_EXPRESSION_CONFIDENCE KW_EXPRESSION_AT KW_EXPRESSION_MAX degree=FUZZY_DEGREE expression=ClassExpressionAtom
;


ClassExpressionRestriction:
    ClassExpressionAttributeMaxCard
  | ClassExpressionPropertyMaxCard
  | ClassExpressionAttributeMinCard
  | ClassExpressionPropertyMinCard
  | ClassExpressionAttributeExactCard
  | ClassExpressionPropertyExactCard
  | ClassExpressionAttributeOnlySome
  | ClassExpressionPropertyOnlySome
  | ClassExpressionAttributeOnly
  | ClassExpressionPropertyOnly
  | ClassExpressionAttributeSome
  | ClassExpressionPropertySome
  | ClassExpressionAttributeValue
  | ClassExpressionPropertyValue
  | ClassExpressionAttributeFuzzy
  | ClassExpressionSelf
  | ClassExpressionAttributePatternRestriction
  | ClassExpressionPropertyPatternRestriction
;

ClassExpressionAttributeMaxCard:
  role=RestrictedAttributeRole KW_EXPRESSION_AT KW_EXPRESSION_MAX cardinality=INT restriction=RestrictedDataExpression
;

ClassExpressionPropertyMaxCard:
  role=RestrictedPropertyRole KW_EXPRESSION_AT KW_EXPRESSION_MAX cardinality=INT restriction=RestrictedClassExpression
;

ClassExpressionAttributeMinCard:
  role=RestrictedAttributeRole KW_EXPRESSION_AT KW_EXPRESSION_MIN cardinality=INT restriction=RestrictedDataExpression
;

ClassExpressionPropertyMinCard:
  role=RestrictedPropertyRole KW_EXPRESSION_AT KW_EXPRESSION_MIN cardinality=INT restriction=RestrictedClassExpression
;

ClassExpressionAttributeExactCard:
  role=RestrictedAttributeRole KW_EXPRESSION_EXACTCARD cardinality=INT restriction=RestrictedDataExpression
;

ClassExpressionPropertyExactCard:
  role=RestrictedPropertyRole KW_EXPRESSION_EXACTCARD cardinality=INT restriction=RestrictedClassExpression
;

ClassExpressionAttributeOnlySome:
  role=RestrictedAttributeRole KW_EXPRESSION_ONLY KW_EXPRESSION_SOME restriction=RestrictedDataExpression ('[' nominal=NominalVariable ']')?
;

ClassExpressionPropertyOnlySome:
  role=RestrictedPropertyRole KW_EXPRESSION_ONLY KW_EXPRESSION_SOME restriction=RestrictedClassExpression ('[' nominal=NominalVariable ']')?
;

ClassExpressionAttributeOnly:
  role=RestrictedAttributeRole KW_EXPRESSION_ONLY restriction=RestrictedDataExpression
;

ClassExpressionPropertyOnly:
  role=RestrictedPropertyRole KW_EXPRESSION_ONLY restriction=RestrictedClassExpression
;

ClassExpressionAttributeSome:
  role=RestrictedAttributeRole KW_EXPRESSION_SOME restriction=RestrictedDataExpression ('[' nominal=NominalVariable ']')?
;

ClassExpressionPropertySome:
  role=RestrictedPropertyRole KW_EXPRESSION_SOME restriction=RestrictedClassExpression ('[' nominal=NominalVariable ']')?
;

ClassExpressionAttributeValue:
  role=RestrictedAttributeRole KW_EXPRESSION_IS restriction=AttributeValueRestriction
;

ClassExpressionPropertyValue:
  role=RestrictedPropertyRole KW_EXPRESSION_IS restriction=PropertyValueRestriction
;

ClassExpressionAttributeFuzzy:
  role=RestrictedAttributeRole KW_EXPRESSION_APPROXIMATE ((low=AttributeNumericValueRestriction high=AttributeNumericValueRestriction)|(range=AttributeNumericValueRestriction))  ('[' nominal=NominalVariable ']')?
;

ClassExpressionSelf:
  role=RestrictedPropertyRole KW_EXPRESSION_SELF
;

ClassExpressionAttributePatternRestriction:
  role=RestrictedAttributeRole pattern=AttributeRestrictionPatternRef args*=PropertyObject kwargs*=PatternKwarg ('[' nominal=NominalVariable ']')?
;

ClassExpressionPropertyPatternRestriction:
  role=RestrictedPropertyRole pattern=PropertyRestrictionPatternRef args*=PropertyObject kwargs*=PatternKwarg ('[' nominal=NominalVariable ']')?
;

RestrictedAttributeRole[skipws]:
  AttributeExpression
;

RestrictedPropertyRole[skipws]:
  PropertyExpression
;

RestrictedAgentRole[skipws]:
    AgentComplement
  | RestrictedAgentExpression
;

RestrictedClassExpression[skipws]:
  ClassExpressionAtom
;

RestrictedDataExpression[skipws]:
  DataExpressionAtom
;




////// Class modals

ClassExpressionModalNecessity:
  KW_EXPRESSION_MODAL_NECESSITY expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalPossibility:
  KW_EXPRESSION_MODAL_POSSIBILITY expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalAssumed:
  KW_EXPRESSION_MODAL_ASSUMPTION expression=RestrictedClassExpression
;

ClassExpressionModalProven:
  KW_EXPRESSION_MODAL_PROVEN expression=RestrictedClassExpression
;

ClassExpressionModalClaimed:
  KW_EXPRESSION_MODAL_CLAIMED expression=RestrictedClassExpression
;

ClassExpressionModalRepeat:
  KW_EXPRESSION_MODAL_REPEAT expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalNever:
  KW_EXPRESSION_MODAL_NEVER expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalInevitable:
  KW_EXPRESSION_MODAL_INEVITABLE expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalOnce:
  KW_EXPRESSION_MODAL_ONCE expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionFuzzyModifier:
  KW_EXPRESSION_FUZZY_MODIFIER a=FLOAT (b=FLOAT c=FLOAT)? expression=RestrictedClassExpression
;

ClassExpressionModalSTIT:
  agent=RestrictedAgentRole KW_EXPRESSION_MODAL_STIT expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalObligation:
  agent=RestrictedAgentRole KW_EXPRESSION_MODAL_OBLIGATION expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalPermission:
  agent=RestrictedAgentRole KW_EXPRESSION_MODAL_PERMISSION expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalProhibition:
  agent=RestrictedAgentRole KW_EXPRESSION_MODAL_PROHIBITION expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalOmission:
  agent=RestrictedAgentRole KW_EXPRESSION_MODAL_OMISSION expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalOption:
  agent=RestrictedAgentRole KW_EXPRESSION_MODAL_OPTION expression=RestrictedClassExpression (KW_EXPRESSION_WHEN condition=RestrictedClassExpression)?
;

ClassExpressionModalPattern:
  pattern=ModalPatternRef expression=ClassExpressionAtom args*=PropertyObject kwargs*=PatternKwargValue
;

AgentComplement:
  KW_EXPRESSION_EXCEPT expression=RestrictedAgentExpression
;

RestrictedAgentExpression:
    RestrictedAgentTop
  | RestrictedAgentBottom
  | RestrictedAgentSelf
  | PropertyValueRestriction
;

RestrictedAgentTop:
  op=KW_EXPRESSION_EVERYONE
;

RestrictedAgentBottom:
  op=KW_EXPRESSION_NOONE
;

RestrictedAgentSelf:
  op=KW_EXPRESSION_THEY
;




////// Temporal connectives

ClassExpressionFutureGlobal: KW_OPERATOR_STEP KW_EXPRESSION_FUTURE_GLOBAL expression=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionFutureLeadsTo: KW_OPERATOR_STEP expression=ClassExpressionFuzz KW_EXPRESSION_FUTURE_LEADSTO trigger=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionFutureNext: KW_OPERATOR_STEP KW_EXPRESSION_FUTURE_NEXT expression=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionFutureRelease: KW_OPERATOR_STEP trigger=ClassExpressionFuzz KW_EXPRESSION_FUTURE_RELEASE expression=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionFutureUnless: KW_OPERATOR_STEP expression=ClassExpressionFuzz KW_EXPRESSION_FUTURE_UNLESS trigger=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionFutureUntil: KW_OPERATOR_STEP expression=ClassExpressionFuzz KW_EXPRESSION_FUTURE_UNTIL trigger=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionPastGlobal: KW_OPERATOR_STEP KW_EXPRESSION_PAST_GLOBAL expression=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionPastNext: KW_OPERATOR_STEP KW_EXPRESSION_PAST_NEXT expression=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionPastUntil: KW_OPERATOR_STEP expression=ClassExpressionFuzz KW_EXPRESSION_PAST_UNTIL trigger=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionPastLeadsTo: KW_OPERATOR_STEP expression=ClassExpressionFuzz KW_EXPRESSION_PAST_LEADSTO trigger=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionPastEventual: KW_OPERATOR_STEP KW_EXPRESSION_PAST_EVENTUAL expression=ClassExpressionFuzz (condition=TemporalCondition)?;
ClassExpressionFutureEventual: KW_OPERATOR_STEP KW_EXPRESSION_FUTURE_EVENTUAL? expression=ClassExpressionFuzz (condition=TemporalCondition)?;

TemporalCondition:
  ((KW_EXPRESSION_AFTER after=TemporalRestriction)? (KW_EXPRESSION_BEFORE before=TemporalRestriction)?)#
;

TemporalRestriction:
    TemporalLiteralExpression
  | NominalAttributeRestriction
;




////// Property expressions

PropertyExpression:
  (
    left_plural=ExpressionPlural expression=PropertyExpressionDisjoint
  )
  |
  (
    expression=PropertyExpressionDisjoint right_plural=ExpressionPlural?
  )
;

PropertyExpressionDisjoint:
    PropertyExpressionDisjunction
  | PropertyExpressionConjoint
;

PropertyExpressionDisjunction:
  disjuncts=PropertyExpressionConjoint KW_EXPRESSION_DISJUNCTION disjuncts+=PropertyExpressionConjoint['or']
;

PropertyExpressionConjoint:
    PropertyExpressionConjunction
  | PropertyExpressionPrimary
;

PropertyExpressionConjunction:
  conjuncts=PropertyExpressionPrimary KW_EXPRESSION_CONJUNCTION conjuncts+=PropertyExpressionPrimary['and']
;

PropertyExpressionPrimary:
    PropertyExpressionComplement
  | PropertyExpressionChain1
;

PropertyExpressionComplement:
  KW_EXPRESSION_COMPLEMENT expression=PropertyExpressionChain1
;

PropertyExpressionChain1:
    PropertyExpressionChain
  | PropertyExpressionAtom
;

PropertyExpressionChain:
  steps=PropertyExpressionAtom KW_GENERIC_OF steps+=PropertyExpressionAtom['of']
;

PropertyExpressionAtom:
    PropertyExpressionTop 
  | PropertyExpressionBottom
  | PropertyExpressionProduct
  | PropertyExpressionInverse
  | ('(' PropertyExpression ')')
  | UniversalVar
  | ExistentialVar
  | QualifiedPropertyRef
  | PropertyRef
;

PropertyExpressionTop:
  expression=KW_EXPRESSION_SOMETHING
;

PropertyExpressionBottom:
  expression=KW_EXPRESSION_NOTHING
;

PropertyExpressionProduct:
  ((KW_GENERIC_FROM domain=ClassExpressionAtom)? (KW_GENERIC_TO range=ClassExpressionAtom)?)#
;

PropertyExpressionInverse:
  KW_EXPRESSION_INVERSE KW_GENERIC_OF expression=PropertyExpressionAtom
;

QualifiedPropertyRef:
  expression=PropertyRef KW_GENERIC_WHICH qualification=ClassRef
;




////// Plurality quantification

ExpressionPlural:
    PluralCumulative
  | PluralDistributive
;

PluralCumulative: op=KW_EXPRESSION_CUMULATIVE;
PluralDistributive: op=KW_EXPRESSION_DISTRIBUTIVE;




////// Attribute expressions

AttributeExpression:
    left_plural=ExpressionPlural? KW_EXPRESSION_VALUE KW_GENERIC_OF expression=AttributeExpressionDisjoint (KW_GENERIC_OF property=PropertyExpression)?
;

AttributeExpressionDisjoint:
    AttributeExpressionDisjunction
  | AttributeExpressionConjoint
;

AttributeExpressionDisjunction:
  disjuncts=AttributeExpressionConjoint KW_EXPRESSION_DISJUNCTION disjuncts+=AttributeExpressionConjoint['or']
;

AttributeExpressionConjoint:
    AttributeExpressionConjunction
  | AttributeExpressionPrimary
;

AttributeExpressionConjunction:
  conjuncts=AttributeExpressionPrimary KW_EXPRESSION_CONJUNCTION conjuncts+=AttributeExpressionPrimary['and']
;

AttributeExpressionPrimary:
    AttributeExpressionComplement
  | AttributeExpressionAtom
;

AttributeExpressionComplement:
  KW_EXPRESSION_COMPLEMENT expression=AttributeExpressionAtom
;

AttributeExpressionAtom:
    AttributeExpressionTop 
  | AttributeExpressionBottom
  | AttributeExpressionProduct
  | ('(' AttributeExpressionDisjoint ')')
  | AttributeRef
;

AttributeExpressionTop:
  expression=KW_EXPRESSION_SOMETHING
;

AttributeExpressionBottom:
  expression=KW_EXPRESSION_NOTHING
;

AttributeExpressionProduct:
  ((KW_GENERIC_FROM domain=ClassExpressionAtom)? (KW_GENERIC_TO range=DataExpressionAtom)?)#
;




////// Data expressions

DataExpression:
  DataExpressionDisjoint
;

DataExpressionDisjoint:
    DataExpressionDisjunction
  | DataExpressionConjoint
;

DataExpressionDisjunction:
  disjuncts=DataExpressionConjoint KW_EXPRESSION_DISJUNCTION disjuncts+=DataExpressionConjoint['or']
;

DataExpressionConjoint:
    DataExpressionConjunction
  | DataExpressionPrimary
;

DataExpressionConjunction:
  conjuncts=DataExpressionPrimary KW_EXPRESSION_CONJUNCTION conjuncts+=DataExpressionPrimary['and']
;

DataExpressionPrimary:
    DataExpressionComplement
  | DataExpressionAtom
;

DataExpressionComplement:
  KW_EXPRESSION_COMPLEMENT expression=DataExpressionAtom
;

DataExpressionAtom:
  DataExpressionTop | DataFacet | ('(' DataExpression ')') | DatatypeRef
;

DataExpressionTop: KW_EXPRESSION_SOMETHING;

DataFacet:
    DataFacetGTE
  | DataFacetGT
  | DataFacetLTE
  | DataFacetLT
  | DataFacetMinLength
  | DataFacetMaxLength
  | DataFacetLength
  | DataFacetMatches
;

DataFacetGTE: KW_OPERATOR_GTE value=NumericFacetExpression;
DataFacetGT: KW_OPERATOR_GT value=NumericFacetExpression;
DataFacetLTE: KW_OPERATOR_LTE value=NumericFacetExpression;
DataFacetLT: KW_OPERATOR_LT value=NumericFacetExpression;
DataFacetMinLength: KW_OPERATOR_LENGTH KW_OPERATOR_GTE value=INT;
DataFacetMaxLength: KW_OPERATOR_LENGTH KW_OPERATOR_LTE value=INT;
DataFacetLength: KW_OPERATOR_LENGTH KW_OPERATOR_EQ value=INT;
DataFacetMatches: KW_OPERATOR_MATCHES value=StringFacetExpression;

NumericFacetExpression:
    UniversalVar
  | NumericLiteralExpression
;

StringFacetExpression:
    UniversalVar
  | StringLiteralExpression
;




////// Value restrictions

AttributeValueRestriction[skipws]:
    NominalAttributeRestriction
  | UniversalVar
  | LiteralExpression
;

AttributeNumericValueRestriction[skipws]:
    NominalAttributeRestriction
  | UniversalVar
  | RangeExpression
  | NumericLiteralExpression
;

PropertyValueRestriction[skipws]:
    NominalPropertyRestriction
  | UniversalVar
  | ExistentialVar
  | IndividualRef
;

NominalAttributeRestriction[skipws]:
  KW_GENERIC_THE KW_EXPRESSION_VALUE KW_GENERIC_OF expression=AttributeExpressionDisjoint is_local?=NominalRestrictionLocal
;

NominalPropertyRestriction[skipws]:
  KW_GENERIC_THE expression=PropertyExpression is_local?=NominalRestrictionLocal
;

NominalRestrictionLocal:
  KW_GENERIC_OF KW_GENERIC_IT
;




////// Infix expressions

InfixExpression:
  InfixAdd
;

InfixAdd:
    InfixAdditive
  | InfixMult
;

InfixAdditive:
  operands=InfixMult operator=KW_INFIX_ADDITIVE operands=InfixAdd
;

InfixMult:
    InfixMultiplicative
  | InfixExp
;

InfixMultiplicative:
  operands=InfixExp operator=KW_INFIX_MULTIPLICATIVE operands=InfixMult
;

InfixExp:
    InfixExponential
  | InfixNumericAtom
;

InfixExponential:
  operands=InfixNumericAtom operator=KW_INFIX_EXPONENTIAL operands=InfixExp
;

InfixNumericAtom:
  UniversalVar | ConstantRef | NumericLiteralExpression | '(' InfixExpression ')' 
;




////// Predicates

Predicate:
  (property=BuiltinPredicate | property=PredicateRef)
  objects+=PropertyObject[',']
;

PropertyObject:
    BNodeDecl
  | GraphDecl
  | HeadedList
  | Collection
  | ObjectRef
  | InfixExpression
  | Literal
;

BuiltinPredicate:
    LogicalIdenticalPredicate
  | LogicalDifferentPredicate
  | NumericEqualsPredicate
  | NumericNotEqualsPredicate
  | NumericLessThanEqualsPredicate
  | NumericLessThanPredicate
  | NumericGreaterThanEqualsPredicate
  | NumericGreaterThanPredicate
  | LogicalEqualsPredicate
  | LogicalNotEqualsPredicate
  | LogicalSemanticsPredicate
  | LogicalConclusionsPredicate
  | CollectionInclusionPredicate
;

LogicalEqualsPredicate: op='= ';
LogicalNotEqualsPredicate: op='=/= ';
NumericEqualsPredicate: op='== ';
NumericNotEqualsPredicate: op='!= ';
NumericLessThanEqualsPredicate: op='<= ';
NumericLessThanPredicate: op='< ';
NumericGreaterThanEqualsPredicate: op='>= ';
NumericGreaterThanPredicate: op='> ';
LogicalSemanticsPredicate: op='|- ';
LogicalConclusionsPredicate: op='|= ';
LogicalIdenticalPredicate: op='=== ';
LogicalDifferentPredicate: op='!== ';
CollectionInclusionPredicate: op='in ';




////// Collections

HeadedList:
  head=PredicateRef '(' members*=HeadedListObject[','] ')'
;

HeadedListObject:
    BNodeDecl
  | GraphDecl
  | HeadedList
  | Collection
  | InfixExpression
  | ObjectRef
  | Literal
;

Collection:
  (collection_type=CollectionType)? '(' members+=PropertyObject[','] ')'
;

CollectionType:
    CollectionTypeBag
  | CollectionTypeSet
  | CollectionTypeAlts
  | CollectionTypeSeq
;

CollectionTypeBag: type=KW_COLLECTIONTYPE_BAG;
CollectionTypeSet: type=KW_COLLECTIONTYPE_SET;
CollectionTypeAlts: type=KW_COLLECTIONTYPE_ALTS;
CollectionTypeSeq: type=KW_COLLECTIONTYPE_SEQ;




////// Variables

UniversalVar:
  universal_var=UNIVAR
;

ExistentialVar:
  existential_var=EXIVAR
;

NominalVariable:
  nominal_var=NOMVAR
;




////// References

GeneralName: IRI | QNAME | UNIVAR | EXIVAR;

OntologyName:
  IRI
;

OntologyRef:
  ref=[OntologyDecl|IRI] (KW_GENERIC_FROM local_file=STRING)?
;

KeywordName: LOCALNAME;

KeywordRef:
  ref=[KeywordPragma|LOCALNAME]
;

IndividualName: GeneralName;

IndividualRef:
  ref=[IndividualDecl|IRI] | ref=[IndividualDecl|QNAME]
;

BNodeName: GeneralName;

BNodeRef:
  ref=[BNodeDecl|IRI] | ref=[BNodeDecl|QNAME]
;

GraphName: GeneralName;

GraphRef:
  ref=[GraphDecl|IRI] | ref=[GraphDecl|QNAME]
;

ClassName: GeneralName;

ClassRef:
  ref=[ClassDecl|IRI] | ref=[ClassDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

PropertyName: GeneralName;

PropertyRef:
  ref=[PropertyDecl|IRI] | ref=[PropertyDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

AttributeName: GeneralName;

AttributeRef:
  ref=[AttributeDecl|IRI] | ref=[AttributeDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

PredicateRef:
  ref=[PropertyDecl|IRI] | ref=[PropertyDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

ObjectRef:
  ref=[IndividualDecl|IRI] | ref=[IndividualDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

DatatypeName: GeneralName;

DatatypeRef:
  ref=[DatatypeDecl|IRI] | ref=[DatatypeDecl|QNAME] | universal_var=UNIVAR | existential_var=EXIVAR
;

ConstantName: GeneralName;

ConstantRef:
  ref=[ConstantDecl|IRI] | ref=[ConstantDecl|QNAME]
;

PatternName: GeneralName;

ClassPatternRef:
  ref=[ClassPatternDecl|IRI] | ref=[ClassPatternDecl|QNAME]
;

PropertyPatternRef:
  ref=[PropertyPatternDecl|IRI] | ref=[PropertyPatternDecl|QNAME]
;

AttributePatternRef:
  ref=[AttributePatternDecl|IRI] | ref=[AttributePatternDecl|QNAME]
;

DatatypePatternRef:
  ref=[DatatypePatternDecl|IRI] | ref=[DatatypePatternDecl|QNAME]
;

IndividualPatternRef:
  ref=[IndividualPatternDecl|IRI] | ref=[IndividualPatternDecl|QNAME]
;

PropertyRestrictionPatternRef:
  ref=[PropertyRestrictionPatternDecl|IRI] | ref=[PropertyRestrictionPatternDecl|QNAME]
;

AttributeRestrictionPatternRef:
  ref=[AttributeRestrictionPatternDecl|IRI] | ref=[AttributeRestrictionPatternDecl|QNAME]
;

ModalPatternRef:
  ref=[ModalPatternDecl|IRI] | ref=[ModalPatternDecl|QNAME]
;

LiteralPatternRef:
  ref=[LiteralPatternDecl|IRI] | ref=[LiteralPatternDecl|QNAME]
;




////// Keywords

KW:
    KW_ENTITY
  | KW_PRAGMA
  | KW_COLLECTIONTYPE
  | KW_GENERIC
  | KW_MODIFIER
  | KW_OPERATOR
  | KW_EXPRESSION
  | KW_INFIX
;

KW_ENTITY:
    KW_ENTITY_ATTRIBUTE
  | KW_ENTITY_ATTRIBUTE_RESTRICTION
  | KW_ENTITY_CLASS
  | KW_ENTITY_CONSTANT
  | KW_ENTITY_DATATYPE
  | KW_ENTITY_INDIVIDUAL
  | KW_ENTITY_LITERAL
  | KW_ENTITY_MODAL
  | KW_ENTITY_ONTOLOGY
  | KW_ENTITY_PATTERN
  | KW_ENTITY_PROPERTY
  | KW_ENTITY_PROPERTY_RESTRICTION
;

KW_ENTITY_ATTRIBUTE: 'attribute';
KW_ENTITY_ATTRIBUTE_RESTRICTION: 'attribute_restriction';
KW_ENTITY_CLASS: 'class';
KW_ENTITY_CONSTANT: 'constant';
KW_ENTITY_DATATYPE: 'datatype';
KW_ENTITY_INDIVIDUAL: 'individual';
KW_ENTITY_LITERAL: 'literal';
KW_ENTITY_MODAL: 'modal';
KW_ENTITY_ONTOLOGY: 'ontology';
KW_ENTITY_PATTERN: 'pattern';
KW_ENTITY_PROPERTY: 'property';
KW_ENTITY_PROPERTY_RESTRICTION: 'property_restriction';


KW_PRAGMA:
    KW_PRAGMA_IMPORT
  | KW_PRAGMA_KEYWORD
;

KW_PRAGMA_IMPORT: 'import';
KW_PRAGMA_KEYWORD: 'keyword';


KW_COLLECTIONTYPE:
    KW_COLLECTIONTYPE_ALTS
  | KW_COLLECTIONTYPE_BAG
  | KW_COLLECTIONTYPE_SEQ
  | KW_COLLECTIONTYPE_SET
;

KW_COLLECTIONTYPE_ALTS: '@alts';
KW_COLLECTIONTYPE_BAG: '@bag';
KW_COLLECTIONTYPE_SEQ: '@seq';
KW_COLLECTIONTYPE_SET: '@set';


KW_GENERIC:
    KW_GENERIC_AS
  | KW_GENERIC_FAILURE
  | KW_GENERIC_FROM
  | KW_GENERIC_IT
  | KW_GENERIC_OF
  | KW_GENERIC_THE
  | KW_GENERIC_TO
  | KW_GENERIC_WHICH
  | KW_GENERIC_WITH
;

KW_GENERIC_AS: 'as';
KW_GENERIC_FAILURE: 'fail';
KW_GENERIC_FROM: 'from';
KW_GENERIC_IT: 'it';
KW_GENERIC_OF: 'of';
KW_GENERIC_THE: 'the';
KW_GENERIC_TO: 'to';
KW_GENERIC_WHICH: 'which';
KW_GENERIC_WITH: 'with';


KW_MODIFIER:
    KW_MODIFIER_EXPORTED
  | KW_MODIFIER_HIDDEN
  | KW_MODIFIER_LABEL
  | KW_MODIFIER_LANGUAGE
  | KW_MODIFIER_PRELUDE
  | KW_MODIFIER_RETURNING
;

KW_MODIFIER_EXPORTED: 'exported';
KW_MODIFIER_HIDDEN: 'hidden';
KW_MODIFIER_LABEL: ':-';
KW_MODIFIER_LANGUAGE: 'language';
KW_MODIFIER_PRELUDE: 'prelude';
KW_MODIFIER_RETURNING: 'returning';


KW_OPERATOR:
    KW_OPERATOR_BACKWARDCHAIN
  | KW_OPERATOR_EQUIVALENCE
  | KW_OPERATOR_FORWARDCHAIN
  | KW_OPERATOR_INSTANCEOF
  | KW_OPERATOR_KEY
  | KW_OPERATOR_PARTITIONS
  | KW_OPERATOR_SPECIALIZES
  | KW_OPERATOR_LTE
  | KW_OPERATOR_LT
  | KW_OPERATOR_GTE
  | KW_OPERATOR_GT
  | KW_OPERATOR_EQ
  | KW_OPERATOR_LENGTH
  | KW_OPERATOR_MATCHES
  | KW_OPERATOR_STEP
;

KW_OPERATOR_BACKWARDCHAIN: '<--';
KW_OPERATOR_EQUIVALENCE: '~=';
KW_OPERATOR_FORWARDCHAIN: '<==';
KW_OPERATOR_INSTANCEOF: 'a';
KW_OPERATOR_KEY: 'key';
KW_OPERATOR_PARTITIONS: 'partitions';
KW_OPERATOR_SPECIALIZES: '<|';
KW_OPERATOR_LTE: '<=';
KW_OPERATOR_LT: '<';
KW_OPERATOR_GTE: '>=';
KW_OPERATOR_GT: '>';
KW_OPERATOR_EQ: '=';
KW_OPERATOR_LENGTH: 'length';
KW_OPERATOR_MATCHES: 'matches';
KW_OPERATOR_STEP: '*';


KW_EXPRESSION:
    KW_EXPRESSION_AFTER
  | KW_EXPRESSION_APPROXIMATE
  | KW_EXPRESSION_AT
  | KW_EXPRESSION_BEFORE
  | KW_EXPRESSION_COMPLEMENT
  | KW_EXPRESSION_CONFIDENCE
  | KW_EXPRESSION_CONJUNCTION
  | KW_EXPRESSION_CUMULATIVE
  | KW_EXPRESSION_DISJUNCTION
  | KW_EXPRESSION_DISTRIBUTIVE
  | KW_EXPRESSION_EVERYONE
  | KW_EXPRESSION_EXACTCARD
  | KW_EXPRESSION_EXCEPT
  | KW_EXPRESSION_FUTURE_EVENTUAL
  | KW_EXPRESSION_FUTURE_GLOBAL
  | KW_EXPRESSION_FUTURE_LEADSTO
  | KW_EXPRESSION_FUTURE_NEXT
  | KW_EXPRESSION_FUTURE_RELEASE
  | KW_EXPRESSION_FUTURE_UNLESS
  | KW_EXPRESSION_FUTURE_UNTIL
  | KW_EXPRESSION_FUZZY_MODIFIER
  | KW_EXPRESSION_IF
  | KW_EXPRESSION_INVERSE
  | KW_EXPRESSION_IS
  | KW_EXPRESSION_MAX
  | KW_EXPRESSION_MIN
  | KW_EXPRESSION_MODAL_ASSUMPTION
  | KW_EXPRESSION_MODAL_CLAIMED
  | KW_EXPRESSION_MODAL_INEVITABLE
  | KW_EXPRESSION_MODAL_NECESSITY
  | KW_EXPRESSION_MODAL_NEVER
  | KW_EXPRESSION_MODAL_OBLIGATION
  | KW_EXPRESSION_MODAL_OMISSION
  | KW_EXPRESSION_MODAL_ONCE
  | KW_EXPRESSION_MODAL_OPTION
  | KW_EXPRESSION_MODAL_PERMISSION
  | KW_EXPRESSION_MODAL_POSSIBILITY
  | KW_EXPRESSION_MODAL_PROHIBITION
  | KW_EXPRESSION_MODAL_PROVEN
  | KW_EXPRESSION_MODAL_REPEAT
  | KW_EXPRESSION_MODAL_STIT
  | KW_EXPRESSION_NOONE
  | KW_EXPRESSION_NOTHING
  | KW_EXPRESSION_ONLY
  | KW_EXPRESSION_PAST_EVENTUAL
  | KW_EXPRESSION_PAST_GLOBAL
  | KW_EXPRESSION_PAST_LEADSTO
  | KW_EXPRESSION_PAST_NEXT
  | KW_EXPRESSION_PAST_UNTIL
  | KW_EXPRESSION_RECURSION
  | KW_EXPRESSION_SELF
  | KW_EXPRESSION_SOMETHING
  | KW_EXPRESSION_SOME
  | KW_EXPRESSION_TEMPORAL_CONJUNCTION
  | KW_EXPRESSION_TEMPORAL_DISJUNCTION
  | KW_EXPRESSION_THAT
  | KW_EXPRESSION_THEY
  | KW_EXPRESSION_VALUE
  | KW_EXPRESSION_WHEN
;

KW_EXPRESSION_AFTER: 'after';
KW_EXPRESSION_APPROXIMATE: 'approximately';
KW_EXPRESSION_AT: 'at';
KW_EXPRESSION_BEFORE: 'before';
KW_EXPRESSION_COMPLEMENT: 'not';
KW_EXPRESSION_CONFIDENCE: 'confidently';
KW_EXPRESSION_CONJUNCTION: 'and';
KW_EXPRESSION_CUMULATIVE: 'variously';
KW_EXPRESSION_DISJUNCTION: 'or';
KW_EXPRESSION_DISTRIBUTIVE: 'separately';
KW_EXPRESSION_EVERYONE: 'everyone';
KW_EXPRESSION_EXACTCARD: 'exactly';
KW_EXPRESSION_EXCEPT: 'except';
KW_EXPRESSION_FUTURE_EVENTUAL: 'eventually';
KW_EXPRESSION_FUTURE_GLOBAL: 'always';
KW_EXPRESSION_FUTURE_LEADSTO: 'were';
KW_EXPRESSION_FUTURE_NEXT: 'next';
KW_EXPRESSION_FUTURE_RELEASE: 'whereupon';
KW_EXPRESSION_FUTURE_UNLESS: 'unless';
KW_EXPRESSION_FUTURE_UNTIL: 'until';
KW_EXPRESSION_FUZZY_MODIFIER: 'graded';
KW_EXPRESSION_IF: 'if';
KW_EXPRESSION_INVERSE: 'inverse';
KW_EXPRESSION_IS: 'is';
KW_EXPRESSION_MAX: 'most';
KW_EXPRESSION_MIN: 'least';
KW_EXPRESSION_MODAL_ASSUMPTION: 'presumably';
KW_EXPRESSION_MODAL_CLAIMED: 'purportedly';
KW_EXPRESSION_MODAL_INEVITABLE: 'inevitably';
KW_EXPRESSION_MODAL_NECESSITY: 'necessarily';
KW_EXPRESSION_MODAL_NEVER: 'never';
KW_EXPRESSION_MODAL_OBLIGATION: 'must_ensure';
KW_EXPRESSION_MODAL_OMISSION: 'might_not_ensure';
KW_EXPRESSION_MODAL_ONCE: 'once';
KW_EXPRESSION_MODAL_OPTION: 'could_ensure';
KW_EXPRESSION_MODAL_PERMISSION: 'may_ensure';
KW_EXPRESSION_MODAL_POSSIBILITY: 'possibly';
KW_EXPRESSION_MODAL_PROHIBITION: 'cannot_ensure';
KW_EXPRESSION_MODAL_PROVEN: 'provably';
KW_EXPRESSION_MODAL_REPEAT: 'repeatedly';
KW_EXPRESSION_MODAL_STIT: 'ensure';
KW_EXPRESSION_NOONE: 'noone';
KW_EXPRESSION_NOTHING: 'nothing';
KW_EXPRESSION_PAST_EVENTUAL: 'was';
KW_EXPRESSION_PAST_GLOBAL: 'historically';
KW_EXPRESSION_PAST_LEADSTO: 'because';
KW_EXPRESSION_PAST_NEXT: 'just';
KW_EXPRESSION_PAST_UNTIL: 'since';
KW_EXPRESSION_ONLY: 'only';
KW_EXPRESSION_RECURSION: 'again';
KW_EXPRESSION_SELF: 'itself';
KW_EXPRESSION_SOMETHING: 'something';
KW_EXPRESSION_SOME: 'a';
KW_EXPRESSION_TEMPORAL_CONJUNCTION: 'together';
KW_EXPRESSION_TEMPORAL_DISJUNCTION: 'either';
KW_EXPRESSION_THAT: 'that'|'where';
KW_EXPRESSION_THEY: 'they'|'them';
KW_EXPRESSION_VALUE: 'value';
KW_EXPRESSION_WHEN: 'when';

KW_INFIX:
    KW_INFIX_ADDITIVE
  | KW_INFIX_MULTIPLICATIVE
  | KW_INFIX_EXPONENTIAL
;

KW_INFIX_ADDITIVE:
  KW_INFIX_ADDITIVE_PLUS | KW_INFIX_ADDITIVE_MINUS
;

KW_INFIX_ADDITIVE_PLUS:
  op='+'
;

KW_INFIX_ADDITIVE_MINUS:
  op='-'
;

KW_INFIX_MULTIPLICATIVE:
  KW_INFIX_MULTIPLICATIVE_TIMES | KW_INFIX_MULTIPLICATIVE_DIVIDE
;

KW_INFIX_MULTIPLICATIVE_TIMES:
  op='*'
;

KW_INFIX_MULTIPLICATIVE_DIVIDE:
  op='/'
;

KW_INFIX_EXPONENTIAL:
  op='^'
;



////// Literals

Literal:
  literal=LiteralExpression dtlang=DTLang?
;

NumericLiteralExpression:
    NoneLiteral
  | DateTimeExpression
  | DurationExpression
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
;

NumberLiteralExpression:
    NoneLiteral
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
;

TemporalLiteralExpression:
    NoneLiteral
  | DateTimeExpression
  | DurationExpression
;

LiteralExpression:
    NoneLiteral
  | DateTimeExpression
  | DurationExpression
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
  | BooleanExpression
  | RegexExpression
  | StringExpression
;

RangeExpression:
  RangeExpressionTemporal | RangeExpressionNumber
;

RangeExpressionNumber:
    RangeExpressionDecimal
  | RangeExpressionRational
  | RangeExpressionInteger
;

RangeExpressionTemporal:
    RangeExpressionDateTime
;

RangeExpressionDateTime:
  (lowerOpen='(' | lowerClosed='[') lower=DateTimeExpression? '..' higher=DateTimeExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionDecimal:
  (lowerOpen='(' | lowerClosed='[') lower=DecimalExpression? '..' higher=DecimalExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionRational:
  (lowerOpen='(' | lowerClosed='[') lower=RationalExpression? '..' higher=RationalExpression? (higherOpen=')' | higherClosed=']')
;

RangeExpressionInteger:
  (lowerOpen='(' | lowerClosed='[') lower=IntegerExpression? '..' higher=IntegerExpression? (higherOpen=')' | higherClosed=']')
;

NoneLiteral: BLANK;

DecimalExpression:
  value=STRICTFLOAT
;

RationalExpression:
  numerator=INT '/' denominator=INT
;

IntegerExpression:
  value=INT
;

BooleanExpression:
  value=BOOL
;

DateTimeExpression:
  value=/(?:[\+-]?\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[\.,]\d+(?!:))?)?(?:\2[0-5]\d(?:[\.,]\d+)?)?(?:[zZ]|(?:[\+-])(?:[01]\d|2[0-3]):?(?:[0-5]\d)?)?)?)?/
;

DurationExpression:
  value=/(-?)P(?=\d|T\d)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)([DW]))?(?:T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?/
  //value=/^P(?!$)((\d+Y)|(\d+\.\d+Y$))?((\d+M)|(\d+\.\d+M$))?((\d+W)|(\d+\.\d+W$))?((\d+D)|(\d+\.\d+D$))?(T(?=\d)((\d+H)|(\d+\.\d+H$))?((\d+M)|(\d+\.\d+M$))?(\d+(\.\d+)?S)?)??$/
;

StringLiteralExpression:
    RegexExpression
  | StringExpression
;

RegexExpression:
  value=/(\/.*\/)/
;

StringExpression:
    value=/(?ms)\"{3}(.*?)\"{3}/
  | value=/(?ms)\'{3}(.*?)\'{3}/
  | value=STRING
  | value=/\'(.*?)\'/
;

DTLang:
    '@' language=LANG
  | '^^' data_type=DatatypeRef
  | unit=IndividualRef
;




////// Lexer

IRI:
  /(<[^>\s]*>)/
;

QNAME:
  !KW /(([A-Za-z_\-][A-Za-z0-9_\-]*\:)?([A-Za-z_\-][A-Za-z0-9_\-]*))/
;

PREFIX:
  /([A-Za-z_\-][A-Za-z0-9_\-]*)/
;

LOCALNAME:
  /([A-Za-z_\-][A-Za-z0-9_\-]*)/
;

UNIVAR:
  /(\?[A-Za-z_\-][A-Za-z0-9_\-]*)/
;

EXIVAR:
  /(\![A-Za-z_\-][A-Za-z0-9_\-]*)/
;

NOMVAR:
  /the\s+\'(.+)\'/
;

LANG:
  /\w{2,3}(-\w{2,3}(-\w{2,3})?)?/
;

FUZZY_DEGREE:
  /(0(\.\d+)?|1(\.0+)?)/
;

BLANK:
  '_'
;

END_OF_OBJ:
  ','
;

END_OF_PROP:
  ';'
;

END_OF_SUBJ:
  '.'
;

Comment:
  /#.*$/
;