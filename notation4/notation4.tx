Ontology:
  'ontology'
  baseIRI=IRI
  noPrelude?=NoPrelude
  (END_OF_PROP
  annotations*=AssertionPredicateBlock[';'])?
  END_OF_SUBJ
  ('default' 'language' lang=LANG END_OF_SUBJ)?
  pragmas*=Pragma
  assertions*=Assertion
;

NoPrelude:
  'without' 'prelude'
;

Pragma:
  Import | Keyword
;

Import:
  'import'
  baseIRI=IRI
  'as'
  name=ID
  ('from'
    fileName=STRING
  )?
  END_OF_SUBJ
;

Keyword:
  export?='exported'
  'keyword'
  ref=ResourceRef
  'as'
  name=ID
  END_OF_SUBJ
;

Assertion:
  (ClassDeclaration | PropertyDeclaration | AttributeDeclaration | DatatypeDeclaration | QuantityDeclaration | FactAssertion | GraphAssertion | BNodeAssertion)
  END_OF_SUBJ
;

ClassDeclaration:
  'class' 
  (subclass=ClassExpressionPrimary | name=ClassRef)
  (END_OF_PROP?
   axioms*=CIAxiom[';']
  )
;

CIAxiom:
    Superclass | EquivalentClass | AssertionPredicateBlock
;

Superclass:
  '<|' superclass=ClassExpression
;

EquivalentClass:
  '===' equivalentclass=ClassExpression
;

PropertyDeclaration:
  (functional?='functional' inverseFunctional?='inversefunctional' reflexive?='reflexive' irreflexive?='irreflexive' symmetric?='symmetric' asymmetric?='asymmetric' transitive?='transitive')#
  'property'
  (subprop=PropertyExpressionChain | name=PropertyRef)
  (END_OF_PROP?
   axioms*=PIAxiom[';']
  )
;

PIAxiom:
  Superproperty | EquivalentProperty | AssertionPredicateBlock
;

Superproperty:
  '<|' superproperty=PropertyExpressionDisjunction
;

EquivalentProperty:
  '===' equivalentProperty=PropertyExpressionDisjunction
;

AttributeDeclaration:
  'attribute'
  name=AttributeRef
  (('with' 'domain' domain=AttributeDomain)? ('with' 'range' range=AttributeRange)?)#
  (END_OF_PROP?
   axioms*=AIAxiom[';']
  )
;

AttributeDomain:
  'domain' domain=ClassExpression
;

AttributeRange:
  'range' range=DataRestriction
;

AIAxiom:
  Superattribute | EquivalentAttribute | AssertionPredicateBlock
;

Superattribute:
  '<|' superattribute=AttributeRef
;

EquivalentAttribute:
  '===' equivalentAttribute=AttributeRef
;

AttributeRef:
  PropertyRef
;

DatatypeDeclaration:
  'datatype' name=DatatypeRef '<|' restriction=DataRestriction
  (END_OF_PROP?
   axioms*=AssertionPredicateBlock[';']
  )
;

DatatypeRef:
  IRIRef | QNameRef
;

QuantityDeclaration:
  'quantity' name=QuantityRef (('with' 'dimension' dimension=DimensionRef)? ('with' 'property' prop=PropertyRef)?)#
  ( END_OF_PROP?
    axioms*=CIAxiom[';']
  )
;

QuantityRef:
  IRIRef | QNameRef
;

DimensionRef:
  IRIRef | QNameRef
;

BNodeAssertion:
  '['
  name=NodeLabel?
  predicates*=AssertionPredicateBlock[';']
  END_OF_PROP?
  ']'
;

GraphAssertion:
 '{'
 name=NodeLabel?
 assertions+=Assertion
 '}'
;

FactAssertion:
  subject=AssertionSubject
  predicates+=AssertionPredicateBlock[';']
;

AssertionPredicateBlock:
  predicate=AssertionPredicate
  objects+=AssertionObject[',']
;


AssertionSubject:
    ResourceRef
  | GraphAssertion
  | BNodeAssertion
;

AssertionPredicate:
    BuiltinPredicate
  | ResourceRef
;

AssertionObject:
    Literal
  | ResourceRef
  | GraphAssertion
  | BNodeAssertion
;

ResourceRef:
  ExistentialVariable | UniversalVariable | IRIRef | QNameRef
;

IRIRef:
  iri=IRI
;

QNameRef[noskipws]:
  /\s*/ (prefix=[Import] ':')? localName=ID
;

NodeLabel:
  ':-'- ResourceRef END_OF_SUBJ-
;

ExistentialVariable:
  '!' name=ID
;

UniversalVariable:
  '?' name=ID
;

BuiltinPredicate:
    IsaPredicate
  | ForwardChainPredicate
;

IsaPredicate: isa?='a';
ForwardChainPredicate: forwardChain?='<==';

ClassRef:
  IRIRef | QNameRef
;

ClassExpression:
  ClassDescription
;

ClassDescription:
  disjuncts+=ClassExpressionConjunction['or']
;

ClassExpressionConjunction:
    (
      baseClass=ClassRef 'that' restrictions+=ClassExpressionPrimary['and']
    | restrictions+=ClassExpressionPrimary['and']
    ) 
    ('if' condition=ClassExpressionPrimary)?
;

ClassExpressionPrimary:
  negated?='not'
  klass=ClassExpressionAtom
;

ClassExpressionRestriction:
    ClassExpressionRestrictionOnlySome
  | ClassExpressionRestrictionOnly
  | ClassExpressionRestrictionSome
  | ClassExpressionRestrictionMaxCard
  | ClassExpressionRestrictionMinCard
  | ClassExpressionRestrictionExactCard
  | ClassExpressionRestrictionQuantity
  | ClassExpressionRestrictionSelf
  | ClassExpressionRestrictionValue
;

ClassExpressionRestrictionOnlySome:
  role=PropertyExpression 'only' 'a' restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionOnly:
  role=PropertyExpression 'only' restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionSome:
  role=PropertyExpression 'a' restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionMaxCard:
  role=PropertyExpression 'at' 'most' cardinality=INT restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionMinCard:
  role=PropertyExpression 'at' 'least' cardinality=INT restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionExactCard:
  role=PropertyExpression 'exactly' cardinality=INT restriction=ClassExpressionPrimary
;

ClassExpressionRestrictionQuantity:
  role=PropertyExpression  'measuring' restriction=DataRestriction unit=ResourceRef (aggregateFunction=ValueAggregateFunction)?
;

ValueAggregateFunction:
  'total' | 'maximum' | 'minimum' | 'average'
;

ClassExpressionRestrictionSelf:
  role=PropertyExpression 'itself'
;

ClassExpressionRestrictionValue:
  role=PropertyExpression 'is' value=ValueRestriction (aggregateFunction=ValueAggregateFunction)?
;


ClassExpressionAtom:
  ClassExpressionModal | ClassExpressionTemporal | ClassExpressionRestriction | ClassExpressionEnumeration | '(' ClassExpression ')' | ClassRef
;

ClassExpressionEnumeration:
  '{' individuals+=ValueRestriction[','] '}'
;

ClassExpressionModal:
  operator=ModalOperator
  klass=ClassExpressionPrimary
  ( 'when'
    condition=ClassExpressionPrimary
  )?
;

ModalOperator:
  'obligated' | 'permitted' | 'prohibited' | 'omissable' | 'optionally' | 'certainly' | 'possibly' | 'currently' | 'definitely' | 'assumedly' | 'repeatedly' | 'never' | 'inevitably'
;

ClassExpressionTemporal:
    ClassExpressionTemporalNext
  | ClassExpressionTemporalEventually
  | ClassExpressionTemporalAlways
  | ClassExpressionTemporalReleases
  | ClassExpressionTemporalUntil
  | ClassExpressionTemporalJust
  | ClassExpressionTemporalWas
  | ClassExpressionTemporalHistorically
  | ClassExpressionTemporalSince
  | ClassExpressionTemporalFrom
;

ClassExpressionTemporalNext:
  'next' klass=ClassExpressionPrimary
;

ClassExpressionTemporalEventually:
  'eventually' klass=ClassExpressionPrimary
;

ClassExpressionTemporalAlways:
  'always' klass=ClassExpressionPrimary
;

ClassExpressionTemporalReleases:
  'up' 'until' trigger=ClassExpressionPrimary klass=ClassExpressionPrimary 
;

ClassExpressionTemporalUntil:
  'until' trigger=ClassExpressionPrimary klass=ClassExpressionPrimary 
;

ClassExpressionTemporalJust:
  'just' klass=ClassExpressionPrimary
;

ClassExpressionTemporalWas:
  'was' klass=ClassExpressionPrimary
;

ClassExpressionTemporalHistorically:
  'historically' klass=ClassExpressionPrimary
;

ClassExpressionTemporalSince:
  'since' trigger=ClassExpressionPrimary klass=ClassExpressionPrimary 
;

ClassExpressionTemporalFrom:
  'from' trigger=ClassExpressionPrimary klass=ClassExpressionPrimary 
;

PropertyRef:
  IRIRef | QNameRef
;

PropertyExpression:
    (leftPlural=PluralOperator prop=PropertyExpressionChain)
  | (prop=PropertyExpressionChain (rightPlural=PluralOperator)?)
;

PluralOperator:
  'some' | 'each'
;

PropertyExpressionChain:
  props+=PropertyExpressionDisjunction['of']
;

PropertyExpressionDisjunction:
  disjuncts+=PropertyExpressionConjunction['or']
;

PropertyExpressionConjunction:
  conjuncts+=PropertyExpressionPrimary['and']
;

PropertyExpressionPrimary:
  negated?='not'
  prop=PropertyExpressionAtom
;

PropertyExpressionAtom:
  PropertyExpressionInverse | PropertyExpressionCartesian | '(' PropertyExpression ')' | PropertyRef
;

PropertyExpressionInverse:
  'inverse' prop=PropertyExpressionPrimary
;

PropertyExpressionCartesian:
  (('with' 'domain' domain=ClassExpressionPrimary)? ('with' 'range' range=ClassExpressionPrimary)?)#
;

DataRestriction:
  ('_' | dataType=ResourceRef) facets*=DataFacetRestriction
;

ValueRestriction:
    LiteralExpression
  | NominalVariable
  | NominalRelationship
  | ResourceRef
;

NominalRelationship:
  'the' prop=PropertyExpressionChain
;

NominalVariable:
  '$' name=ID
;

DataFacetRestriction:
  '[' DataFacet ']'
;

DataFacet:
    '>' minExclusive=NumericLiteralExpression
  | '>=' minInclusive=NumericLiteralExpression
  | '<' maxExclusive=NumericLiteralExpression
  | '<=' maxInclusive=NumericLiteralExpression
  | '=' equal=NumericLiteralExpression
  | 'length' '<' maxExclusiveLength=INT
  | 'length' '<=' maxInclusiveLength=INT
  | 'length' '>' minExclusiveLength=INT
  | 'length' '>=' minInclusiveLength=INT
  | 'length' '=' length=INT
  | 'matches' pattern=STRING
;

Literal:
  literal=LiteralExpression dtlang=DTLang?
;

NumericLiteralExpression:
    DateTimeExpression
  | TimeExpression
  | DateExpression
  | DurationExpression
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
;

LiteralExpression:
    DateTimeExpression
  | TimeExpression
  | DateExpression
  | DurationExpression
  | DecimalExpression
  | RationalExpression
  | IntegerExpression
  | BooleanExpression
  | StringExpression
  | ExistentialVariable
  | UniversalVariable
;

// FIXME: These would be great, if we can find a single way to desugar them
RangeExpression:
    lower=DateTimeExpression '..' upper=DateTimeExpression
  | lower=TimeExpression '..' upper=TimeExpression
  | lower=DateExpression '..' upper=DateExpression
  | lower=DecimalExpression '..' upper=DecimalExpression
  | lower=RationalExpression '..' upper=RationalExpression
  | lower=IntegerExpression '..' upper=IntegerExpression
;


DecimalExpression:
  value=STRICTFLOAT
;

RationalExpression:
  numerator=INT '/' denominator=INT
;

IntegerExpression:
  value=INT
;

BooleanExpression:
  value=BOOL
;

DateExpression:
  value=/(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?/
;

TimeExpression:
  value=/(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?/
;

DateTimeExpression:
  value=/(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?/
;

DurationExpression:
  value=/P(?!$)((\d+Y)|(\d+\.\d+Y$))?((\d+M)|(\d+\.\d+M$))?((\d+W)|(\d+\.\d+W$))?((\d+D)|(\d+\.\d+D$))?(T(?=\d)((\d+H)|(\d+\.\d+H$))?((\d+M)|(\d+\.\d+M$))?(\d+(\.\d+)?S)?)??/
;

StringExpression:
    value=/(?ms)\"{3}(.*?)\"{3}/
  | value=/(?ms)\'{3}(.*?)\'{3}/
  | value=STRING
  | value=/\'(.*?)\'/
;

DTLang:
    '@' language=LANG
  | '^^' dtype=ResourceRef
  | unit=ResourceRef
;

// Lexical declarations

IRI:            // An explicit IRI
  /<([^>]*)>/
;

LANG:           // A language code
  /\w{2,3}(-\w{2,3}(-\w{2,3})?)?/
;

END_OF_OBJ:
  ','
;

END_OF_PROP:
  ';'
;

END_OF_SUBJ:
  '.'?
;

Comment:        // A comment
  /#.*$/
;
